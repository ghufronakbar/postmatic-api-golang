// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: business_rss_subscription.sql

package entity

import (
	"context"
	"database/sql"
	"time"
)

const countBusinessRssSubscriptionsByBusinessRootID = `-- name: CountBusinessRssSubscriptionsByBusinessRootID :one
SELECT COUNT(*)::bigint AS total
FROM business_rss_subscriptions brs
LEFT JOIN app_rss_feeds arf
  ON arf.id = brs.app_rss_feed_id
  AND arf.deleted_at IS NULL
LEFT JOIN app_rss_categories arc
  ON arc.id = arf.app_rss_category_id
  AND arc.deleted_at IS NULL
WHERE
  brs.business_root_id = $1
  AND brs.deleted_at IS NULL
  AND (
    COALESCE($2, '') = ''
    OR brs.title ILIKE ('%' || $2 || '%')
    OR COALESCE(arf.title, '') ILIKE ('%' || $2 || '%')
    OR COALESCE(arf.publisher, '') ILIKE ('%' || $2 || '%')
    OR COALESCE(arf.url, '') ILIKE ('%' || $2 || '%')
    OR COALESCE(arc.name, '') ILIKE ('%' || $2 || '%')
  )
`

type CountBusinessRssSubscriptionsByBusinessRootIDParams struct {
	BusinessRootID int64       `json:"business_root_id"`
	Search         interface{} `json:"search"`
}

func (q *Queries) CountBusinessRssSubscriptionsByBusinessRootID(ctx context.Context, arg CountBusinessRssSubscriptionsByBusinessRootIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBusinessRssSubscriptionsByBusinessRootID, arg.BusinessRootID, arg.Search)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createBusinessRssSubscription = `-- name: CreateBusinessRssSubscription :one
INSERT INTO business_rss_subscriptions (
  business_root_id,
  title,
  is_active,
  app_rss_feed_id
) VALUES (
  $1,
  $2,
  $3,
  $4
) RETURNING id, title, is_active, business_root_id, created_at, updated_at, deleted_at, app_rss_feed_id
`

type CreateBusinessRssSubscriptionParams struct {
	BusinessRootID int64  `json:"business_root_id"`
	Title          string `json:"title"`
	IsActive       bool   `json:"is_active"`
	AppRssFeedID   int64  `json:"app_rss_feed_id"`
}

func (q *Queries) CreateBusinessRssSubscription(ctx context.Context, arg CreateBusinessRssSubscriptionParams) (BusinessRssSubscription, error) {
	row := q.db.QueryRowContext(ctx, createBusinessRssSubscription,
		arg.BusinessRootID,
		arg.Title,
		arg.IsActive,
		arg.AppRssFeedID,
	)
	var i BusinessRssSubscription
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IsActive,
		&i.BusinessRootID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AppRssFeedID,
	)
	return i, err
}

const editBusinessRssSubscription = `-- name: EditBusinessRssSubscription :one
UPDATE business_rss_subscriptions
SET
  title = $1,
  is_active = $2,
  app_rss_feed_id = $3
WHERE id = $4
RETURNING id, title, is_active, business_root_id, created_at, updated_at, deleted_at, app_rss_feed_id
`

type EditBusinessRssSubscriptionParams struct {
	Title        string `json:"title"`
	IsActive     bool   `json:"is_active"`
	AppRssFeedID int64  `json:"app_rss_feed_id"`
	ID           int64  `json:"id"`
}

func (q *Queries) EditBusinessRssSubscription(ctx context.Context, arg EditBusinessRssSubscriptionParams) (BusinessRssSubscription, error) {
	row := q.db.QueryRowContext(ctx, editBusinessRssSubscription,
		arg.Title,
		arg.IsActive,
		arg.AppRssFeedID,
		arg.ID,
	)
	var i BusinessRssSubscription
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IsActive,
		&i.BusinessRootID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AppRssFeedID,
	)
	return i, err
}

const existsBusinessRssSubscriptionByBusinessRootIDAndFeedIDExceptID = `-- name: ExistsBusinessRssSubscriptionByBusinessRootIDAndFeedIDExceptID :one
SELECT EXISTS (
  SELECT 1
  FROM business_rss_subscriptions
  WHERE business_root_id = $1
    AND app_rss_feed_id = $2
    AND deleted_at IS NULL
    AND id <> $3
) AS exists
`

type ExistsBusinessRssSubscriptionByBusinessRootIDAndFeedIDExceptIDParams struct {
	BusinessRootID int64 `json:"business_root_id"`
	AppRssFeedID   int64 `json:"app_rss_feed_id"`
	ID             int64 `json:"id"`
}

func (q *Queries) ExistsBusinessRssSubscriptionByBusinessRootIDAndFeedIDExceptID(ctx context.Context, arg ExistsBusinessRssSubscriptionByBusinessRootIDAndFeedIDExceptIDParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsBusinessRssSubscriptionByBusinessRootIDAndFeedIDExceptID, arg.BusinessRootID, arg.AppRssFeedID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getBusinessRssSubscriptionByBusinessRootIdAndAppRssFeedId = `-- name: GetBusinessRssSubscriptionByBusinessRootIdAndAppRssFeedId :one
SELECT id, title, is_active, business_root_id, created_at, updated_at, deleted_at, app_rss_feed_id FROM business_rss_subscriptions
WHERE business_root_id = $1
AND app_rss_feed_id = $2
AND deleted_at IS NULL
`

type GetBusinessRssSubscriptionByBusinessRootIdAndAppRssFeedIdParams struct {
	BusinessRootID int64 `json:"business_root_id"`
	AppRssFeedID   int64 `json:"app_rss_feed_id"`
}

func (q *Queries) GetBusinessRssSubscriptionByBusinessRootIdAndAppRssFeedId(ctx context.Context, arg GetBusinessRssSubscriptionByBusinessRootIdAndAppRssFeedIdParams) (BusinessRssSubscription, error) {
	row := q.db.QueryRowContext(ctx, getBusinessRssSubscriptionByBusinessRootIdAndAppRssFeedId, arg.BusinessRootID, arg.AppRssFeedID)
	var i BusinessRssSubscription
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IsActive,
		&i.BusinessRootID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AppRssFeedID,
	)
	return i, err
}

const getBusinessRssSubscriptionByIDAndBusinessRootID = `-- name: GetBusinessRssSubscriptionByIDAndBusinessRootID :one
SELECT id, title, is_active, business_root_id, created_at, updated_at, deleted_at, app_rss_feed_id
FROM business_rss_subscriptions
WHERE id = $1
  AND business_root_id = $2
  AND deleted_at IS NULL
LIMIT 1
`

type GetBusinessRssSubscriptionByIDAndBusinessRootIDParams struct {
	ID             int64 `json:"id"`
	BusinessRootID int64 `json:"business_root_id"`
}

func (q *Queries) GetBusinessRssSubscriptionByIDAndBusinessRootID(ctx context.Context, arg GetBusinessRssSubscriptionByIDAndBusinessRootIDParams) (BusinessRssSubscription, error) {
	row := q.db.QueryRowContext(ctx, getBusinessRssSubscriptionByIDAndBusinessRootID, arg.ID, arg.BusinessRootID)
	var i BusinessRssSubscription
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IsActive,
		&i.BusinessRootID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AppRssFeedID,
	)
	return i, err
}

const getBusinessRssSubscriptionById = `-- name: GetBusinessRssSubscriptionById :one
SELECT id, title, is_active, business_root_id, created_at, updated_at, deleted_at, app_rss_feed_id FROM business_rss_subscriptions
WHERE id = $1
`

func (q *Queries) GetBusinessRssSubscriptionById(ctx context.Context, id int64) (BusinessRssSubscription, error) {
	row := q.db.QueryRowContext(ctx, getBusinessRssSubscriptionById, id)
	var i BusinessRssSubscription
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IsActive,
		&i.BusinessRootID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AppRssFeedID,
	)
	return i, err
}

const getBusinessRssSubscriptionsByBusinessRootID = `-- name: GetBusinessRssSubscriptionsByBusinessRootID :many
SELECT
  -- business_rss_subscriptions (include created_at & updated_at)
  brs.id              AS subscription_id,
  brs.title           AS subscription_title,
  brs.is_active       AS subscription_is_active,
  brs.business_root_id AS subscription_business_root_id,
  brs.app_rss_feed_id AS subscription_app_rss_feed_id,
  brs.created_at      AS subscription_created_at,
  brs.updated_at      AS subscription_updated_at,
  brs.deleted_at      AS subscription_deleted_at,

  -- app_rss_feeds (exclude created_at & updated_at)
  arf.id                AS feed_id,
  arf.title             AS feed_title,
  arf.url               AS feed_url,
  arf.publisher         AS feed_publisher,
  arf.app_rss_category_id AS feed_app_rss_category_id,
  arf.deleted_at        AS feed_deleted_at,

  -- app_rss_categories (exclude created_at & updated_at)
  arc.id         AS category_id,
  arc.name       AS category_name,
  arc.deleted_at AS category_deleted_at

FROM business_rss_subscriptions brs
LEFT JOIN app_rss_feeds arf
  ON arf.id = brs.app_rss_feed_id
  AND arf.deleted_at IS NULL
LEFT JOIN app_rss_categories arc
  ON arc.id = arf.app_rss_category_id
  AND arc.deleted_at IS NULL

WHERE
  brs.business_root_id = $1
  AND brs.deleted_at IS NULL
  AND (
    COALESCE($2, '') = ''
    OR brs.title ILIKE ('%' || $2 || '%')
    OR COALESCE(arf.title, '') ILIKE ('%' || $2 || '%')
    OR COALESCE(arf.publisher, '') ILIKE ('%' || $2 || '%')
    OR COALESCE(arf.url, '') ILIKE ('%' || $2 || '%')
    OR COALESCE(arc.name, '') ILIKE ('%' || $2 || '%')
  )

ORDER BY
  -- title
  CASE WHEN $3 = 'title' AND $4 = 'asc'  THEN brs.title END ASC,
  CASE WHEN $3 = 'title' AND $4 = 'desc' THEN brs.title END DESC,

  -- created_at
  CASE WHEN $3 = 'created_at' AND $4 = 'asc'  THEN brs.created_at END ASC,
  CASE WHEN $3 = 'created_at' AND $4 = 'desc' THEN brs.created_at END DESC,

  -- updated_at
  CASE WHEN $3 = 'updated_at' AND $4 = 'asc'  THEN brs.updated_at END ASC,
  CASE WHEN $3 = 'updated_at' AND $4 = 'desc' THEN brs.updated_at END DESC,

  CASE WHEN $3 = 'id' AND $4 = 'asc'  THEN brs.id END ASC,
  CASE WHEN $3 = 'id' AND $4 = 'desc' THEN brs.id END DESC,

  -- fallback stable order
  brs.id DESC

LIMIT $6
OFFSET $5
`

type GetBusinessRssSubscriptionsByBusinessRootIDParams struct {
	BusinessRootID int64       `json:"business_root_id"`
	Search         interface{} `json:"search"`
	SortBy         interface{} `json:"sort_by"`
	SortDir        interface{} `json:"sort_dir"`
	PageOffset     int32       `json:"page_offset"`
	PageLimit      int32       `json:"page_limit"`
}

type GetBusinessRssSubscriptionsByBusinessRootIDRow struct {
	SubscriptionID             int64          `json:"subscription_id"`
	SubscriptionTitle          string         `json:"subscription_title"`
	SubscriptionIsActive       bool           `json:"subscription_is_active"`
	SubscriptionBusinessRootID int64          `json:"subscription_business_root_id"`
	SubscriptionAppRssFeedID   int64          `json:"subscription_app_rss_feed_id"`
	SubscriptionCreatedAt      time.Time      `json:"subscription_created_at"`
	SubscriptionUpdatedAt      time.Time      `json:"subscription_updated_at"`
	SubscriptionDeletedAt      sql.NullTime   `json:"subscription_deleted_at"`
	FeedID                     sql.NullInt64  `json:"feed_id"`
	FeedTitle                  sql.NullString `json:"feed_title"`
	FeedUrl                    sql.NullString `json:"feed_url"`
	FeedPublisher              sql.NullString `json:"feed_publisher"`
	FeedAppRssCategoryID       sql.NullInt64  `json:"feed_app_rss_category_id"`
	FeedDeletedAt              sql.NullTime   `json:"feed_deleted_at"`
	CategoryID                 sql.NullInt64  `json:"category_id"`
	CategoryName               sql.NullString `json:"category_name"`
	CategoryDeletedAt          sql.NullTime   `json:"category_deleted_at"`
}

func (q *Queries) GetBusinessRssSubscriptionsByBusinessRootID(ctx context.Context, arg GetBusinessRssSubscriptionsByBusinessRootIDParams) ([]GetBusinessRssSubscriptionsByBusinessRootIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getBusinessRssSubscriptionsByBusinessRootID,
		arg.BusinessRootID,
		arg.Search,
		arg.SortBy,
		arg.SortDir,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBusinessRssSubscriptionsByBusinessRootIDRow
	for rows.Next() {
		var i GetBusinessRssSubscriptionsByBusinessRootIDRow
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.SubscriptionTitle,
			&i.SubscriptionIsActive,
			&i.SubscriptionBusinessRootID,
			&i.SubscriptionAppRssFeedID,
			&i.SubscriptionCreatedAt,
			&i.SubscriptionUpdatedAt,
			&i.SubscriptionDeletedAt,
			&i.FeedID,
			&i.FeedTitle,
			&i.FeedUrl,
			&i.FeedPublisher,
			&i.FeedAppRssCategoryID,
			&i.FeedDeletedAt,
			&i.CategoryID,
			&i.CategoryName,
			&i.CategoryDeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteBusinessRssSubscriptionByID = `-- name: HardDeleteBusinessRssSubscriptionByID :exec
DELETE FROM business_rss_subscriptions
WHERE id = $1
`

func (q *Queries) HardDeleteBusinessRssSubscriptionByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, hardDeleteBusinessRssSubscriptionByID, id)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: business_root.sql

package entity

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countJoinedBusinessesByProfileID = `-- name: CountJoinedBusinessesByProfileID :one
SELECT COUNT(*)::bigint AS total
FROM business_members bm
JOIN business_roots br
  ON br.id = bm.business_root_id
JOIN business_knowledges bk
  ON bk.business_root_id = br.id
WHERE
  bm.profile_id = $1
  AND bm.status = 'accepted'
  AND bk.deleted_at IS NULL
  AND (
    COALESCE($2, '') = ''
    OR bk.name ILIKE ('%' || $2 || '%')
  )
  AND (
    $3::date IS NULL
    OR COALESCE(bm.answered_at)::date >= $3::date
  )
  AND (
    $4::date IS NULL
    OR COALESCE(bm.answered_at)::date <= $4::date
  )
`

type CountJoinedBusinessesByProfileIDParams struct {
	ProfileID uuid.UUID    `json:"profile_id"`
	Search    interface{}  `json:"search"`
	DateStart sql.NullTime `json:"date_start"`
	DateEnd   sql.NullTime `json:"date_end"`
}

func (q *Queries) CountJoinedBusinessesByProfileID(ctx context.Context, arg CountJoinedBusinessesByProfileIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJoinedBusinessesByProfileID,
		arg.ProfileID,
		arg.Search,
		arg.DateStart,
		arg.DateEnd,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createBusinessRoot = `-- name: CreateBusinessRoot :one
INSERT INTO business_roots 
DEFAULT VALUES
RETURNING id
`

func (q *Queries) CreateBusinessRoot(ctx context.Context) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createBusinessRoot)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getBusinessRootById = `-- name: GetBusinessRootById :one
SELECT id, deleted_at
FROM business_roots
WHERE id = $1
`

type GetBusinessRootByIdRow struct {
	ID        uuid.UUID    `json:"id"`
	DeletedAt sql.NullTime `json:"deleted_at"`
}

func (q *Queries) GetBusinessRootById(ctx context.Context, id uuid.UUID) (GetBusinessRootByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getBusinessRootById, id)
	var i GetBusinessRootByIdRow
	err := row.Scan(&i.ID, &i.DeletedAt)
	return i, err
}

const getJoinedBusinessesByProfileID = `-- name: GetJoinedBusinessesByProfileID :many
SELECT
  bm.id                AS member_id,
  bm.status            AS member_status,
  bm.role              AS member_role,
  bm.answered_at       AS member_answered_at,

  br.id                AS business_root_id,
  br.created_at        AS business_root_created_at,
  br.updated_at        AS business_root_updated_at,

  bk.name              AS business_name,
  bk.description       AS business_description,
  bk.primary_logo_url  AS business_logo_url

FROM business_members bm
JOIN business_roots br
  ON br.id = bm.business_root_id
JOIN business_knowledges bk
  ON bk.business_root_id = br.id

WHERE
  bm.profile_id = $1
  AND br.deleted_at IS NULL
  AND bm.status = 'accepted'
  AND bk.deleted_at IS NULL
  AND (
    COALESCE($2, '') = ''
    OR bk.name ILIKE ('%' || $2 || '%')
  )
  AND (
    $3::date IS NULL
    OR COALESCE(bm.answered_at)::date >= $3::date
  )
  AND (
    $4::date IS NULL
    OR COALESCE(bm.answered_at)::date <= $4::date
  )

ORDER BY
  -- name
  CASE WHEN $5 = 'name' AND $6 = 'asc'  THEN bk.name END ASC,
  CASE WHEN $5 = 'name' AND $6 = 'desc' THEN bk.name END DESC,

  -- created_at
  CASE WHEN $5 = 'created_at' AND $6 = 'asc'  THEN br.created_at END ASC,
  CASE WHEN $5 = 'created_at' AND $6 = 'desc' THEN br.created_at END DESC,

  -- updated_at
  CASE WHEN $5 = 'updated_at' AND $6 = 'asc'  THEN br.updated_at END ASC,
  CASE WHEN $5 = 'updated_at' AND $6 = 'desc' THEN br.updated_at END DESC,

  -- fallback stable order
  br.created_at DESC,
  br.id DESC

LIMIT $8
OFFSET $7
`

type GetJoinedBusinessesByProfileIDParams struct {
	ProfileID  uuid.UUID    `json:"profile_id"`
	Search     interface{}  `json:"search"`
	DateStart  sql.NullTime `json:"date_start"`
	DateEnd    sql.NullTime `json:"date_end"`
	SortBy     interface{}  `json:"sort_by"`
	SortDir    interface{}  `json:"sort_dir"`
	PageOffset int32        `json:"page_offset"`
	PageLimit  int32        `json:"page_limit"`
}

type GetJoinedBusinessesByProfileIDRow struct {
	MemberID              uuid.UUID            `json:"member_id"`
	MemberStatus          BusinessMemberStatus `json:"member_status"`
	MemberRole            BusinessMemberRole   `json:"member_role"`
	MemberAnsweredAt      sql.NullTime         `json:"member_answered_at"`
	BusinessRootID        uuid.UUID            `json:"business_root_id"`
	BusinessRootCreatedAt time.Time            `json:"business_root_created_at"`
	BusinessRootUpdatedAt time.Time            `json:"business_root_updated_at"`
	BusinessName          string               `json:"business_name"`
	BusinessDescription   sql.NullString       `json:"business_description"`
	BusinessLogoUrl       sql.NullString       `json:"business_logo_url"`
}

func (q *Queries) GetJoinedBusinessesByProfileID(ctx context.Context, arg GetJoinedBusinessesByProfileIDParams) ([]GetJoinedBusinessesByProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getJoinedBusinessesByProfileID,
		arg.ProfileID,
		arg.Search,
		arg.DateStart,
		arg.DateEnd,
		arg.SortBy,
		arg.SortDir,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJoinedBusinessesByProfileIDRow
	for rows.Next() {
		var i GetJoinedBusinessesByProfileIDRow
		if err := rows.Scan(
			&i.MemberID,
			&i.MemberStatus,
			&i.MemberRole,
			&i.MemberAnsweredAt,
			&i.BusinessRootID,
			&i.BusinessRootCreatedAt,
			&i.BusinessRootUpdatedAt,
			&i.BusinessName,
			&i.BusinessDescription,
			&i.BusinessLogoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteBusinessRoot = `-- name: SoftDeleteBusinessRoot :one
UPDATE business_roots
SET deleted_at = NOW()
WHERE id = $1
RETURNING id
`

func (q *Queries) SoftDeleteBusinessRoot(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, softDeleteBusinessRoot, id)
	err := row.Scan(&id)
	return id, err
}

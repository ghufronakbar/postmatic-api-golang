// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: business_image_content.sql

package entity

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const countBusinessImageContentsByBusinessRootId = `-- name: CountBusinessImageContentsByBusinessRootId :one
SELECT COUNT(*)::bigint AS total
FROM business_image_contents b
WHERE
  b.business_root_id = $1
  AND b.deleted_at IS NULL

  -- search (name + description)
  AND (
    COALESCE($2, '') = ''
    OR b.caption ILIKE ('%' || $2 || '%')
    OR COALESCE(b.category, '') ILIKE ('%' || $2 || '%')
  )

  -- ready_to_post
  AND (
    $3::boolean IS NULL
    OR b.ready_to_post = $3
  )

  -- date range (berdasarkan created_at)
  AND (
    $4::date IS NULL
    OR b.created_at::date >= $4::date
  )
  AND (
    $5::date IS NULL
    OR b.created_at::date <= $5::date
  )
`

type CountBusinessImageContentsByBusinessRootIdParams struct {
	BusinessRootID int64        `json:"business_root_id"`
	Search         interface{}  `json:"search"`
	ReadyToPost    sql.NullBool `json:"ready_to_post"`
	DateStart      sql.NullTime `json:"date_start"`
	DateEnd        sql.NullTime `json:"date_end"`
}

func (q *Queries) CountBusinessImageContentsByBusinessRootId(ctx context.Context, arg CountBusinessImageContentsByBusinessRootIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBusinessImageContentsByBusinessRootId,
		arg.BusinessRootID,
		arg.Search,
		arg.ReadyToPost,
		arg.DateStart,
		arg.DateEnd,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createBusinessImageContent = `-- name: CreateBusinessImageContent :one
INSERT INTO business_image_contents (
    caption,
    type,
    ready_to_post,
    category,
    image_urls,
    business_root_id,
    business_product_id
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING id, image_urls, caption, type, ready_to_post, category, business_product_id, business_root_id, created_at, updated_at, deleted_at
`

type CreateBusinessImageContentParams struct {
	Caption           sql.NullString           `json:"caption"`
	Type              BusinessImageContentType `json:"type"`
	ReadyToPost       bool                     `json:"ready_to_post"`
	Category          string                   `json:"category"`
	ImageUrls         []string                 `json:"image_urls"`
	BusinessRootID    int64                    `json:"business_root_id"`
	BusinessProductID sql.NullInt64            `json:"business_product_id"`
}

func (q *Queries) CreateBusinessImageContent(ctx context.Context, arg CreateBusinessImageContentParams) (BusinessImageContent, error) {
	row := q.db.QueryRowContext(ctx, createBusinessImageContent,
		arg.Caption,
		arg.Type,
		arg.ReadyToPost,
		arg.Category,
		pq.Array(arg.ImageUrls),
		arg.BusinessRootID,
		arg.BusinessProductID,
	)
	var i BusinessImageContent
	err := row.Scan(
		&i.ID,
		pq.Array(&i.ImageUrls),
		&i.Caption,
		&i.Type,
		&i.ReadyToPost,
		&i.Category,
		&i.BusinessProductID,
		&i.BusinessRootID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getBusinessImageContentsByBusinessRootId = `-- name: GetBusinessImageContentsByBusinessRootId :many
WITH p AS (
  SELECT
    COALESCE(NULLIF($8,  ''), 'created_at') AS sort_by,
    COALESCE(NULLIF($9, ''), 'desc')       AS sort_dir
)
SELECT b.id, b.image_urls, b.caption, b.type, b.ready_to_post, b.category, b.business_product_id, b.business_root_id, b.created_at, b.updated_at, b.deleted_at
FROM business_image_contents b
CROSS JOIN p
WHERE
  b.business_root_id = $1
  AND b.deleted_at IS NULL

  -- search (name + description)
  AND (
    COALESCE($2, '') = ''
    OR b.caption ILIKE ('%' || $2 || '%')
    OR COALESCE(b.category, '') ILIKE ('%' || $2 || '%')
  )

  -- ready_to_post
  AND (
    $3::boolean IS NULL
    OR b.ready_to_post = $3
  )

  -- date range (berdasarkan created_at)
  AND (
    $4::date IS NULL
    OR b.created_at::date >= $4::date
  )
  AND (
    $5::date IS NULL
    OR b.created_at::date <= $5::date
  )

ORDER BY
  -- caption
  CASE WHEN p.sort_by = 'caption' AND p.sort_dir = 'asc'  THEN b.caption END ASC,
  CASE WHEN p.sort_by = 'caption' AND p.sort_dir = 'desc' THEN b.caption END DESC,

  -- created_at
  CASE WHEN p.sort_by = 'created_at' AND p.sort_dir = 'asc'  THEN b.created_at END ASC,
  CASE WHEN p.sort_by = 'created_at' AND p.sort_dir = 'desc' THEN b.created_at END DESC,

  -- updated_at
  CASE WHEN p.sort_by = 'updated_at' AND p.sort_dir = 'asc'  THEN b.updated_at END ASC,
  CASE WHEN p.sort_by = 'updated_at' AND p.sort_dir = 'desc' THEN b.updated_at END DESC,

  -- id
  CASE WHEN p.sort_by = 'id' AND p.sort_dir = 'asc'  THEN b.id END ASC,
  CASE WHEN p.sort_by = 'id' AND p.sort_dir = 'desc' THEN b.id END DESC,

  -- fallback stable order
  b.id DESC

LIMIT $7
OFFSET $6
`

type GetBusinessImageContentsByBusinessRootIdParams struct {
	BusinessRootID int64        `json:"business_root_id"`
	Search         interface{}  `json:"search"`
	ReadyToPost    sql.NullBool `json:"ready_to_post"`
	DateStart      sql.NullTime `json:"date_start"`
	DateEnd        sql.NullTime `json:"date_end"`
	PageOffset     int32        `json:"page_offset"`
	PageLimit      int32        `json:"page_limit"`
	SortBy         interface{}  `json:"sort_by"`
	SortDir        interface{}  `json:"sort_dir"`
}

func (q *Queries) GetBusinessImageContentsByBusinessRootId(ctx context.Context, arg GetBusinessImageContentsByBusinessRootIdParams) ([]BusinessImageContent, error) {
	rows, err := q.db.QueryContext(ctx, getBusinessImageContentsByBusinessRootId,
		arg.BusinessRootID,
		arg.Search,
		arg.ReadyToPost,
		arg.DateStart,
		arg.DateEnd,
		arg.PageOffset,
		arg.PageLimit,
		arg.SortBy,
		arg.SortDir,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BusinessImageContent
	for rows.Next() {
		var i BusinessImageContent
		if err := rows.Scan(
			&i.ID,
			pq.Array(&i.ImageUrls),
			&i.Caption,
			&i.Type,
			&i.ReadyToPost,
			&i.Category,
			&i.BusinessProductID,
			&i.BusinessRootID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteBusinessImageContentByBusinessImageContentId = `-- name: SoftDeleteBusinessImageContentByBusinessImageContentId :one
UPDATE business_image_contents
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, image_urls, caption, type, ready_to_post, category, business_product_id, business_root_id, created_at, updated_at, deleted_at
`

func (q *Queries) SoftDeleteBusinessImageContentByBusinessImageContentId(ctx context.Context, id int64) (BusinessImageContent, error) {
	row := q.db.QueryRowContext(ctx, softDeleteBusinessImageContentByBusinessImageContentId, id)
	var i BusinessImageContent
	err := row.Scan(
		&i.ID,
		pq.Array(&i.ImageUrls),
		&i.Caption,
		&i.Type,
		&i.ReadyToPost,
		&i.Category,
		&i.BusinessProductID,
		&i.BusinessRootID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateBusinessImageContent = `-- name: UpdateBusinessImageContent :one
UPDATE business_image_contents
SET
    caption = $1,
    type = $2,
    ready_to_post = $3,
    category = $4,
    image_urls = $5
WHERE id = $6
RETURNING id, image_urls, caption, type, ready_to_post, category, business_product_id, business_root_id, created_at, updated_at, deleted_at
`

type UpdateBusinessImageContentParams struct {
	Caption     sql.NullString           `json:"caption"`
	Type        BusinessImageContentType `json:"type"`
	ReadyToPost bool                     `json:"ready_to_post"`
	Category    string                   `json:"category"`
	ImageUrls   []string                 `json:"image_urls"`
	ID          int64                    `json:"id"`
}

func (q *Queries) UpdateBusinessImageContent(ctx context.Context, arg UpdateBusinessImageContentParams) (BusinessImageContent, error) {
	row := q.db.QueryRowContext(ctx, updateBusinessImageContent,
		arg.Caption,
		arg.Type,
		arg.ReadyToPost,
		arg.Category,
		pq.Array(arg.ImageUrls),
		arg.ID,
	)
	var i BusinessImageContent
	err := row.Scan(
		&i.ID,
		pq.Array(&i.ImageUrls),
		&i.Caption,
		&i.Type,
		&i.ReadyToPost,
		&i.Category,
		&i.BusinessProductID,
		&i.BusinessRootID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

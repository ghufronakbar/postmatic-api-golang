// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: app_rss_feed.sql

package entity

import (
	"context"

	"github.com/google/uuid"
)

const countAllRSSFeed = `-- name: CountAllRSSFeed :one
SELECT COUNT(*)::bigint AS total
FROM app_rss_feeds f
WHERE
  f.deleted_at IS NULL
  AND (
    COALESCE($1, '') = ''
    OR f.title ILIKE ('%' || $1 || '%')
    OR f.publisher ILIKE ('%' || $1 || '%')
    OR f.url ILIKE ('%' || $1 || '%')
  )
  AND (
    $2::uuid IS NULL
    OR f.app_rss_category_id = $2::uuid
  )
`

type CountAllRSSFeedParams struct {
	Search   interface{}   `json:"search"`
	Category uuid.NullUUID `json:"category"`
}

func (q *Queries) CountAllRSSFeed(ctx context.Context, arg CountAllRSSFeedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllRSSFeed, arg.Search, arg.Category)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getAllRSSFeed = `-- name: GetAllRSSFeed :many
SELECT
  f.id, f.title, f.url, f.publisher, f.app_rss_category_id, f.deleted_at, f.created_at, f.updated_at
FROM app_rss_feeds f
WHERE
  f.deleted_at IS NULL
  AND (
    COALESCE($1, '') = ''
    OR f.title ILIKE ('%' || $1 || '%')
    OR f.publisher ILIKE ('%' || $1 || '%')
    OR f.url ILIKE ('%' || $1 || '%')
  )
  AND (
    $2::uuid IS NULL
    OR f.app_rss_category_id = $2::uuid
  )
ORDER BY
  -- title
  CASE WHEN $3 = 'title' AND $4 = 'asc'  THEN f.title END ASC,
  CASE WHEN $3 = 'title' AND $4 = 'desc' THEN f.title END DESC,

  -- created_at
  CASE WHEN $3 = 'created_at' AND $4 = 'asc'  THEN f.created_at END ASC,
  CASE WHEN $3 = 'created_at' AND $4 = 'desc' THEN f.created_at END DESC,

  -- updated_at
  CASE WHEN $3 = 'updated_at' AND $4 = 'asc'  THEN f.updated_at END ASC,
  CASE WHEN $3 = 'updated_at' AND $4 = 'desc' THEN f.updated_at END DESC,

  -- fallback stable order
  f.created_at DESC,
  f.id DESC
LIMIT $6
OFFSET $5
`

type GetAllRSSFeedParams struct {
	Search     interface{}   `json:"search"`
	Category   uuid.NullUUID `json:"category"`
	SortBy     interface{}   `json:"sort_by"`
	SortDir    interface{}   `json:"sort_dir"`
	PageOffset int32         `json:"page_offset"`
	PageLimit  int32         `json:"page_limit"`
}

func (q *Queries) GetAllRSSFeed(ctx context.Context, arg GetAllRSSFeedParams) ([]AppRssFeed, error) {
	rows, err := q.db.QueryContext(ctx, getAllRSSFeed,
		arg.Search,
		arg.Category,
		arg.SortBy,
		arg.SortDir,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppRssFeed
	for rows.Next() {
		var i AppRssFeed
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Url,
			&i.Publisher,
			&i.AppRssCategoryID,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment_history.sql

package entity

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countAllPaymentHistories = `-- name: CountAllPaymentHistories :one
SELECT COUNT(*)::bigint AS total
FROM payment_histories p
WHERE
    p.deleted_at IS NULL
    AND p.profile_id = $1
    AND (
        COALESCE($2, '') = ''
        OR p.record_product_name ILIKE ('%' || $2 || '%')
        OR p.payment_method ILIKE ('%' || $2 || '%')
    )
    AND (
        $3::payment_status IS NULL
        OR p.status = $3::payment_status
    )
`

type CountAllPaymentHistoriesParams struct {
	ProfileID uuid.UUID         `json:"profile_id"`
	Search    interface{}       `json:"search"`
	Status    NullPaymentStatus `json:"status"`
}

func (q *Queries) CountAllPaymentHistories(ctx context.Context, arg CountAllPaymentHistoriesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllPaymentHistories, arg.ProfileID, arg.Search, arg.Status)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countAllPaymentHistoriesByBusiness = `-- name: CountAllPaymentHistoriesByBusiness :one
SELECT COUNT(*)::bigint AS total
FROM payment_histories p
WHERE
    p.deleted_at IS NULL
    AND p.business_root_id = $1
    AND (
        COALESCE($2, '') = ''
        OR p.record_product_name ILIKE ('%' || $2 || '%')
        OR p.payment_method ILIKE ('%' || $2 || '%')
    )
    AND (
        $3::payment_status IS NULL
        OR p.status = $3::payment_status
    )
`

type CountAllPaymentHistoriesByBusinessParams struct {
	BusinessRootID int64             `json:"business_root_id"`
	Search         interface{}       `json:"search"`
	Status         NullPaymentStatus `json:"status"`
}

func (q *Queries) CountAllPaymentHistoriesByBusiness(ctx context.Context, arg CountAllPaymentHistoriesByBusinessParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllPaymentHistoriesByBusiness, arg.BusinessRootID, arg.Search, arg.Status)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createPaymentHistory = `-- name: CreatePaymentHistory :one
INSERT INTO payment_histories (
    profile_id,
    business_root_id,
    product_amount,
    status,
    currency,
    payment_method,
    payment_method_type,
    record_product_name,
    record_product_type,
    record_product_price,
    record_product_image_url,
    reference_product_id,
    subtotal_item_amount,
    discount_amount,
    discount_percentage,
    discount_type,
    admin_fee_amount,
    admin_fee_percentage,
    admin_fee_type,
    tax_amount,
    tax_percentage,
    referral_record_id,
    midtrans_transaction_id,
    midtrans_expired_at,
    payment_pending_at,
    total_amount
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26
) RETURNING id, profile_id, business_root_id, product_amount, status, currency, payment_method, payment_method_type, record_product_name, record_product_type, record_product_price, record_product_image_url, reference_product_id, subtotal_item_amount, discount_amount, discount_percentage, discount_type, admin_fee_amount, admin_fee_percentage, admin_fee_type, tax_amount, tax_percentage, referral_record_id, midtrans_transaction_id, midtrans_expired_at, payment_pending_at, payment_success_at, payment_failed_at, payment_canceled_at, payment_expired_at, payment_refunded_at, total_amount, created_at, updated_at, deleted_at
`

type CreatePaymentHistoryParams struct {
	ProfileID             uuid.UUID          `json:"profile_id"`
	BusinessRootID        int64              `json:"business_root_id"`
	ProductAmount         int64              `json:"product_amount"`
	Status                PaymentStatus      `json:"status"`
	Currency              string             `json:"currency"`
	PaymentMethod         string             `json:"payment_method"`
	PaymentMethodType     string             `json:"payment_method_type"`
	RecordProductName     string             `json:"record_product_name"`
	RecordProductType     PaymentProductType `json:"record_product_type"`
	RecordProductPrice    int64              `json:"record_product_price"`
	RecordProductImageUrl string             `json:"record_product_image_url"`
	ReferenceProductID    uuid.UUID          `json:"reference_product_id"`
	SubtotalItemAmount    int64              `json:"subtotal_item_amount"`
	DiscountAmount        int64              `json:"discount_amount"`
	DiscountPercentage    sql.NullInt32      `json:"discount_percentage"`
	DiscountType          DiscountType       `json:"discount_type"`
	AdminFeeAmount        int64              `json:"admin_fee_amount"`
	AdminFeePercentage    sql.NullInt32      `json:"admin_fee_percentage"`
	AdminFeeType          DiscountType       `json:"admin_fee_type"`
	TaxAmount             int64              `json:"tax_amount"`
	TaxPercentage         int32              `json:"tax_percentage"`
	ReferralRecordID      sql.NullInt64      `json:"referral_record_id"`
	MidtransTransactionID sql.NullString     `json:"midtrans_transaction_id"`
	MidtransExpiredAt     sql.NullTime       `json:"midtrans_expired_at"`
	PaymentPendingAt      sql.NullTime       `json:"payment_pending_at"`
	TotalAmount           int64              `json:"total_amount"`
}

func (q *Queries) CreatePaymentHistory(ctx context.Context, arg CreatePaymentHistoryParams) (PaymentHistory, error) {
	row := q.db.QueryRowContext(ctx, createPaymentHistory,
		arg.ProfileID,
		arg.BusinessRootID,
		arg.ProductAmount,
		arg.Status,
		arg.Currency,
		arg.PaymentMethod,
		arg.PaymentMethodType,
		arg.RecordProductName,
		arg.RecordProductType,
		arg.RecordProductPrice,
		arg.RecordProductImageUrl,
		arg.ReferenceProductID,
		arg.SubtotalItemAmount,
		arg.DiscountAmount,
		arg.DiscountPercentage,
		arg.DiscountType,
		arg.AdminFeeAmount,
		arg.AdminFeePercentage,
		arg.AdminFeeType,
		arg.TaxAmount,
		arg.TaxPercentage,
		arg.ReferralRecordID,
		arg.MidtransTransactionID,
		arg.MidtransExpiredAt,
		arg.PaymentPendingAt,
		arg.TotalAmount,
	)
	var i PaymentHistory
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.ProductAmount,
		&i.Status,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentMethodType,
		&i.RecordProductName,
		&i.RecordProductType,
		&i.RecordProductPrice,
		&i.RecordProductImageUrl,
		&i.ReferenceProductID,
		&i.SubtotalItemAmount,
		&i.DiscountAmount,
		&i.DiscountPercentage,
		&i.DiscountType,
		&i.AdminFeeAmount,
		&i.AdminFeePercentage,
		&i.AdminFeeType,
		&i.TaxAmount,
		&i.TaxPercentage,
		&i.ReferralRecordID,
		&i.MidtransTransactionID,
		&i.MidtransExpiredAt,
		&i.PaymentPendingAt,
		&i.PaymentSuccessAt,
		&i.PaymentFailedAt,
		&i.PaymentCanceledAt,
		&i.PaymentExpiredAt,
		&i.PaymentRefundedAt,
		&i.TotalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAllPaymentHistories = `-- name: GetAllPaymentHistories :many
SELECT p.id, p.profile_id, p.business_root_id, p.product_amount, p.status, p.currency, p.payment_method, p.payment_method_type, p.record_product_name, p.record_product_type, p.record_product_price, p.record_product_image_url, p.reference_product_id, p.subtotal_item_amount, p.discount_amount, p.discount_percentage, p.discount_type, p.admin_fee_amount, p.admin_fee_percentage, p.admin_fee_type, p.tax_amount, p.tax_percentage, p.referral_record_id, p.midtrans_transaction_id, p.midtrans_expired_at, p.payment_pending_at, p.payment_success_at, p.payment_failed_at, p.payment_canceled_at, p.payment_expired_at, p.payment_refunded_at, p.total_amount, p.created_at, p.updated_at, p.deleted_at
FROM payment_histories p
WHERE
    p.deleted_at IS NULL
    AND p.profile_id = $1
    AND (
        COALESCE($2, '') = ''
        OR p.record_product_name ILIKE ('%' || $2 || '%')
        OR p.payment_method ILIKE ('%' || $2 || '%')
    )
    AND (
        $3::payment_status IS NULL
        OR p.status = $3::payment_status
    )
ORDER BY
    CASE WHEN $4 = 'created_at' AND $5 = 'asc' THEN p.created_at END ASC,
    CASE WHEN $4 = 'created_at' AND $5 = 'desc' THEN p.created_at END DESC,
    CASE WHEN $4 = 'total_amount' AND $5 = 'asc' THEN p.total_amount END ASC,
    CASE WHEN $4 = 'total_amount' AND $5 = 'desc' THEN p.total_amount END DESC,
    p.created_at DESC
LIMIT $7
OFFSET $6
`

type GetAllPaymentHistoriesParams struct {
	ProfileID  uuid.UUID         `json:"profile_id"`
	Search     interface{}       `json:"search"`
	Status     NullPaymentStatus `json:"status"`
	SortBy     interface{}       `json:"sort_by"`
	SortDir    interface{}       `json:"sort_dir"`
	PageOffset int32             `json:"page_offset"`
	PageLimit  int32             `json:"page_limit"`
}

func (q *Queries) GetAllPaymentHistories(ctx context.Context, arg GetAllPaymentHistoriesParams) ([]PaymentHistory, error) {
	rows, err := q.db.QueryContext(ctx, getAllPaymentHistories,
		arg.ProfileID,
		arg.Search,
		arg.Status,
		arg.SortBy,
		arg.SortDir,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentHistory
	for rows.Next() {
		var i PaymentHistory
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.BusinessRootID,
			&i.ProductAmount,
			&i.Status,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentMethodType,
			&i.RecordProductName,
			&i.RecordProductType,
			&i.RecordProductPrice,
			&i.RecordProductImageUrl,
			&i.ReferenceProductID,
			&i.SubtotalItemAmount,
			&i.DiscountAmount,
			&i.DiscountPercentage,
			&i.DiscountType,
			&i.AdminFeeAmount,
			&i.AdminFeePercentage,
			&i.AdminFeeType,
			&i.TaxAmount,
			&i.TaxPercentage,
			&i.ReferralRecordID,
			&i.MidtransTransactionID,
			&i.MidtransExpiredAt,
			&i.PaymentPendingAt,
			&i.PaymentSuccessAt,
			&i.PaymentFailedAt,
			&i.PaymentCanceledAt,
			&i.PaymentExpiredAt,
			&i.PaymentRefundedAt,
			&i.TotalAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPaymentHistoriesByBusiness = `-- name: GetAllPaymentHistoriesByBusiness :many
SELECT p.id, p.profile_id, p.business_root_id, p.product_amount, p.status, p.currency, p.payment_method, p.payment_method_type, p.record_product_name, p.record_product_type, p.record_product_price, p.record_product_image_url, p.reference_product_id, p.subtotal_item_amount, p.discount_amount, p.discount_percentage, p.discount_type, p.admin_fee_amount, p.admin_fee_percentage, p.admin_fee_type, p.tax_amount, p.tax_percentage, p.referral_record_id, p.midtrans_transaction_id, p.midtrans_expired_at, p.payment_pending_at, p.payment_success_at, p.payment_failed_at, p.payment_canceled_at, p.payment_expired_at, p.payment_refunded_at, p.total_amount, p.created_at, p.updated_at, p.deleted_at
FROM payment_histories p
WHERE
    p.deleted_at IS NULL
    AND p.business_root_id = $1
    AND (
        COALESCE($2, '') = ''
        OR p.record_product_name ILIKE ('%' || $2 || '%')
        OR p.payment_method ILIKE ('%' || $2 || '%')
    )
    AND (
        $3::payment_status IS NULL
        OR p.status = $3::payment_status
    )
ORDER BY
    CASE WHEN $4 = 'created_at' AND $5 = 'asc' THEN p.created_at END ASC,
    CASE WHEN $4 = 'created_at' AND $5 = 'desc' THEN p.created_at END DESC,
    CASE WHEN $4 = 'total_amount' AND $5 = 'asc' THEN p.total_amount END ASC,
    CASE WHEN $4 = 'total_amount' AND $5 = 'desc' THEN p.total_amount END DESC,
    p.created_at DESC
LIMIT $7
OFFSET $6
`

type GetAllPaymentHistoriesByBusinessParams struct {
	BusinessRootID int64             `json:"business_root_id"`
	Search         interface{}       `json:"search"`
	Status         NullPaymentStatus `json:"status"`
	SortBy         interface{}       `json:"sort_by"`
	SortDir        interface{}       `json:"sort_dir"`
	PageOffset     int32             `json:"page_offset"`
	PageLimit      int32             `json:"page_limit"`
}

func (q *Queries) GetAllPaymentHistoriesByBusiness(ctx context.Context, arg GetAllPaymentHistoriesByBusinessParams) ([]PaymentHistory, error) {
	rows, err := q.db.QueryContext(ctx, getAllPaymentHistoriesByBusiness,
		arg.BusinessRootID,
		arg.Search,
		arg.Status,
		arg.SortBy,
		arg.SortDir,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentHistory
	for rows.Next() {
		var i PaymentHistory
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.BusinessRootID,
			&i.ProductAmount,
			&i.Status,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentMethodType,
			&i.RecordProductName,
			&i.RecordProductType,
			&i.RecordProductPrice,
			&i.RecordProductImageUrl,
			&i.ReferenceProductID,
			&i.SubtotalItemAmount,
			&i.DiscountAmount,
			&i.DiscountPercentage,
			&i.DiscountType,
			&i.AdminFeeAmount,
			&i.AdminFeePercentage,
			&i.AdminFeeType,
			&i.TaxAmount,
			&i.TaxPercentage,
			&i.ReferralRecordID,
			&i.MidtransTransactionID,
			&i.MidtransExpiredAt,
			&i.PaymentPendingAt,
			&i.PaymentSuccessAt,
			&i.PaymentFailedAt,
			&i.PaymentCanceledAt,
			&i.PaymentExpiredAt,
			&i.PaymentRefundedAt,
			&i.TotalAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentHistoryById = `-- name: GetPaymentHistoryById :one
SELECT id, profile_id, business_root_id, product_amount, status, currency, payment_method, payment_method_type, record_product_name, record_product_type, record_product_price, record_product_image_url, reference_product_id, subtotal_item_amount, discount_amount, discount_percentage, discount_type, admin_fee_amount, admin_fee_percentage, admin_fee_type, tax_amount, tax_percentage, referral_record_id, midtrans_transaction_id, midtrans_expired_at, payment_pending_at, payment_success_at, payment_failed_at, payment_canceled_at, payment_expired_at, payment_refunded_at, total_amount, created_at, updated_at, deleted_at FROM payment_histories
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPaymentHistoryById(ctx context.Context, id uuid.UUID) (PaymentHistory, error) {
	row := q.db.QueryRowContext(ctx, getPaymentHistoryById, id)
	var i PaymentHistory
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.ProductAmount,
		&i.Status,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentMethodType,
		&i.RecordProductName,
		&i.RecordProductType,
		&i.RecordProductPrice,
		&i.RecordProductImageUrl,
		&i.ReferenceProductID,
		&i.SubtotalItemAmount,
		&i.DiscountAmount,
		&i.DiscountPercentage,
		&i.DiscountType,
		&i.AdminFeeAmount,
		&i.AdminFeePercentage,
		&i.AdminFeeType,
		&i.TaxAmount,
		&i.TaxPercentage,
		&i.ReferralRecordID,
		&i.MidtransTransactionID,
		&i.MidtransExpiredAt,
		&i.PaymentPendingAt,
		&i.PaymentSuccessAt,
		&i.PaymentFailedAt,
		&i.PaymentCanceledAt,
		&i.PaymentExpiredAt,
		&i.PaymentRefundedAt,
		&i.TotalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPaymentHistoryByIdAndBusiness = `-- name: GetPaymentHistoryByIdAndBusiness :one
SELECT id, profile_id, business_root_id, product_amount, status, currency, payment_method, payment_method_type, record_product_name, record_product_type, record_product_price, record_product_image_url, reference_product_id, subtotal_item_amount, discount_amount, discount_percentage, discount_type, admin_fee_amount, admin_fee_percentage, admin_fee_type, tax_amount, tax_percentage, referral_record_id, midtrans_transaction_id, midtrans_expired_at, payment_pending_at, payment_success_at, payment_failed_at, payment_canceled_at, payment_expired_at, payment_refunded_at, total_amount, created_at, updated_at, deleted_at FROM payment_histories
WHERE id = $1 AND business_root_id = $2 AND deleted_at IS NULL
`

type GetPaymentHistoryByIdAndBusinessParams struct {
	ID             uuid.UUID `json:"id"`
	BusinessRootID int64     `json:"business_root_id"`
}

func (q *Queries) GetPaymentHistoryByIdAndBusiness(ctx context.Context, arg GetPaymentHistoryByIdAndBusinessParams) (PaymentHistory, error) {
	row := q.db.QueryRowContext(ctx, getPaymentHistoryByIdAndBusiness, arg.ID, arg.BusinessRootID)
	var i PaymentHistory
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.ProductAmount,
		&i.Status,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentMethodType,
		&i.RecordProductName,
		&i.RecordProductType,
		&i.RecordProductPrice,
		&i.RecordProductImageUrl,
		&i.ReferenceProductID,
		&i.SubtotalItemAmount,
		&i.DiscountAmount,
		&i.DiscountPercentage,
		&i.DiscountType,
		&i.AdminFeeAmount,
		&i.AdminFeePercentage,
		&i.AdminFeeType,
		&i.TaxAmount,
		&i.TaxPercentage,
		&i.ReferralRecordID,
		&i.MidtransTransactionID,
		&i.MidtransExpiredAt,
		&i.PaymentPendingAt,
		&i.PaymentSuccessAt,
		&i.PaymentFailedAt,
		&i.PaymentCanceledAt,
		&i.PaymentExpiredAt,
		&i.PaymentRefundedAt,
		&i.TotalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPaymentHistoryByIdAndProfile = `-- name: GetPaymentHistoryByIdAndProfile :one
SELECT id, profile_id, business_root_id, product_amount, status, currency, payment_method, payment_method_type, record_product_name, record_product_type, record_product_price, record_product_image_url, reference_product_id, subtotal_item_amount, discount_amount, discount_percentage, discount_type, admin_fee_amount, admin_fee_percentage, admin_fee_type, tax_amount, tax_percentage, referral_record_id, midtrans_transaction_id, midtrans_expired_at, payment_pending_at, payment_success_at, payment_failed_at, payment_canceled_at, payment_expired_at, payment_refunded_at, total_amount, created_at, updated_at, deleted_at FROM payment_histories
WHERE id = $1 AND profile_id = $2 AND deleted_at IS NULL
`

type GetPaymentHistoryByIdAndProfileParams struct {
	ID        uuid.UUID `json:"id"`
	ProfileID uuid.UUID `json:"profile_id"`
}

func (q *Queries) GetPaymentHistoryByIdAndProfile(ctx context.Context, arg GetPaymentHistoryByIdAndProfileParams) (PaymentHistory, error) {
	row := q.db.QueryRowContext(ctx, getPaymentHistoryByIdAndProfile, arg.ID, arg.ProfileID)
	var i PaymentHistory
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.ProductAmount,
		&i.Status,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentMethodType,
		&i.RecordProductName,
		&i.RecordProductType,
		&i.RecordProductPrice,
		&i.RecordProductImageUrl,
		&i.ReferenceProductID,
		&i.SubtotalItemAmount,
		&i.DiscountAmount,
		&i.DiscountPercentage,
		&i.DiscountType,
		&i.AdminFeeAmount,
		&i.AdminFeePercentage,
		&i.AdminFeeType,
		&i.TaxAmount,
		&i.TaxPercentage,
		&i.ReferralRecordID,
		&i.MidtransTransactionID,
		&i.MidtransExpiredAt,
		&i.PaymentPendingAt,
		&i.PaymentSuccessAt,
		&i.PaymentFailedAt,
		&i.PaymentCanceledAt,
		&i.PaymentExpiredAt,
		&i.PaymentRefundedAt,
		&i.TotalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPaymentHistoryByMidtransTransactionId = `-- name: GetPaymentHistoryByMidtransTransactionId :one
SELECT id, profile_id, business_root_id, product_amount, status, currency, payment_method, payment_method_type, record_product_name, record_product_type, record_product_price, record_product_image_url, reference_product_id, subtotal_item_amount, discount_amount, discount_percentage, discount_type, admin_fee_amount, admin_fee_percentage, admin_fee_type, tax_amount, tax_percentage, referral_record_id, midtrans_transaction_id, midtrans_expired_at, payment_pending_at, payment_success_at, payment_failed_at, payment_canceled_at, payment_expired_at, payment_refunded_at, total_amount, created_at, updated_at, deleted_at FROM payment_histories
WHERE midtrans_transaction_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPaymentHistoryByMidtransTransactionId(ctx context.Context, midtransTransactionID sql.NullString) (PaymentHistory, error) {
	row := q.db.QueryRowContext(ctx, getPaymentHistoryByMidtransTransactionId, midtransTransactionID)
	var i PaymentHistory
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.ProductAmount,
		&i.Status,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentMethodType,
		&i.RecordProductName,
		&i.RecordProductType,
		&i.RecordProductPrice,
		&i.RecordProductImageUrl,
		&i.ReferenceProductID,
		&i.SubtotalItemAmount,
		&i.DiscountAmount,
		&i.DiscountPercentage,
		&i.DiscountType,
		&i.AdminFeeAmount,
		&i.AdminFeePercentage,
		&i.AdminFeeType,
		&i.TaxAmount,
		&i.TaxPercentage,
		&i.ReferralRecordID,
		&i.MidtransTransactionID,
		&i.MidtransExpiredAt,
		&i.PaymentPendingAt,
		&i.PaymentSuccessAt,
		&i.PaymentFailedAt,
		&i.PaymentCanceledAt,
		&i.PaymentExpiredAt,
		&i.PaymentRefundedAt,
		&i.TotalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePaymentHistoryMidtransId = `-- name: UpdatePaymentHistoryMidtransId :one
UPDATE payment_histories
SET midtrans_transaction_id = $2
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, profile_id, business_root_id, product_amount, status, currency, payment_method, payment_method_type, record_product_name, record_product_type, record_product_price, record_product_image_url, reference_product_id, subtotal_item_amount, discount_amount, discount_percentage, discount_type, admin_fee_amount, admin_fee_percentage, admin_fee_type, tax_amount, tax_percentage, referral_record_id, midtrans_transaction_id, midtrans_expired_at, payment_pending_at, payment_success_at, payment_failed_at, payment_canceled_at, payment_expired_at, payment_refunded_at, total_amount, created_at, updated_at, deleted_at
`

type UpdatePaymentHistoryMidtransIdParams struct {
	ID                    uuid.UUID      `json:"id"`
	MidtransTransactionID sql.NullString `json:"midtrans_transaction_id"`
}

func (q *Queries) UpdatePaymentHistoryMidtransId(ctx context.Context, arg UpdatePaymentHistoryMidtransIdParams) (PaymentHistory, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentHistoryMidtransId, arg.ID, arg.MidtransTransactionID)
	var i PaymentHistory
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.ProductAmount,
		&i.Status,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentMethodType,
		&i.RecordProductName,
		&i.RecordProductType,
		&i.RecordProductPrice,
		&i.RecordProductImageUrl,
		&i.ReferenceProductID,
		&i.SubtotalItemAmount,
		&i.DiscountAmount,
		&i.DiscountPercentage,
		&i.DiscountType,
		&i.AdminFeeAmount,
		&i.AdminFeePercentage,
		&i.AdminFeeType,
		&i.TaxAmount,
		&i.TaxPercentage,
		&i.ReferralRecordID,
		&i.MidtransTransactionID,
		&i.MidtransExpiredAt,
		&i.PaymentPendingAt,
		&i.PaymentSuccessAt,
		&i.PaymentFailedAt,
		&i.PaymentCanceledAt,
		&i.PaymentExpiredAt,
		&i.PaymentRefundedAt,
		&i.TotalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePaymentHistoryStatus = `-- name: UpdatePaymentHistoryStatus :one
UPDATE payment_histories
SET 
    status = $1::payment_status,
    payment_success_at = CASE WHEN $1::payment_status = 'success'::payment_status THEN NOW() ELSE payment_success_at END,
    payment_failed_at = CASE WHEN $1::payment_status = 'failed'::payment_status THEN NOW() ELSE payment_failed_at END,
    payment_canceled_at = CASE WHEN $1::payment_status = 'canceled'::payment_status THEN NOW() ELSE payment_canceled_at END,
    payment_expired_at = CASE WHEN $1::payment_status = 'expired'::payment_status THEN NOW() ELSE payment_expired_at END,
    payment_refunded_at = CASE WHEN $1::payment_status = 'refunded'::payment_status THEN NOW() ELSE payment_refunded_at END
WHERE id = $2 AND deleted_at IS NULL
RETURNING id, profile_id, business_root_id, product_amount, status, currency, payment_method, payment_method_type, record_product_name, record_product_type, record_product_price, record_product_image_url, reference_product_id, subtotal_item_amount, discount_amount, discount_percentage, discount_type, admin_fee_amount, admin_fee_percentage, admin_fee_type, tax_amount, tax_percentage, referral_record_id, midtrans_transaction_id, midtrans_expired_at, payment_pending_at, payment_success_at, payment_failed_at, payment_canceled_at, payment_expired_at, payment_refunded_at, total_amount, created_at, updated_at, deleted_at
`

type UpdatePaymentHistoryStatusParams struct {
	Status PaymentStatus `json:"status"`
	ID     uuid.UUID     `json:"id"`
}

func (q *Queries) UpdatePaymentHistoryStatus(ctx context.Context, arg UpdatePaymentHistoryStatusParams) (PaymentHistory, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentHistoryStatus, arg.Status, arg.ID)
	var i PaymentHistory
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.ProductAmount,
		&i.Status,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentMethodType,
		&i.RecordProductName,
		&i.RecordProductType,
		&i.RecordProductPrice,
		&i.RecordProductImageUrl,
		&i.ReferenceProductID,
		&i.SubtotalItemAmount,
		&i.DiscountAmount,
		&i.DiscountPercentage,
		&i.DiscountType,
		&i.AdminFeeAmount,
		&i.AdminFeePercentage,
		&i.AdminFeeType,
		&i.TaxAmount,
		&i.TaxPercentage,
		&i.ReferralRecordID,
		&i.MidtransTransactionID,
		&i.MidtransExpiredAt,
		&i.PaymentPendingAt,
		&i.PaymentSuccessAt,
		&i.PaymentFailedAt,
		&i.PaymentCanceledAt,
		&i.PaymentExpiredAt,
		&i.PaymentRefundedAt,
		&i.TotalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

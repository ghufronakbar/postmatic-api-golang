// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: member.sql

package entity

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getMembersByBusinessRootIDs = `-- name: GetMembersByBusinessRootIDs :many
SELECT
  bm.business_root_id,
  bm.status,
  bm.role,

  p.id        AS profile_id,
  p.name      AS profile_name,
  p.image_url AS profile_image_url,
  p.email     AS profile_email

FROM business_members bm
JOIN profiles p
  ON p.id = bm.profile_id

WHERE bm.business_root_id = ANY($1::uuid[])

ORDER BY bm.business_root_id, bm.created_at ASC
`

type GetMembersByBusinessRootIDsRow struct {
	BusinessRootID  uuid.UUID            `json:"business_root_id"`
	Status          BusinessMemberStatus `json:"status"`
	Role            BusinessMemberRole   `json:"role"`
	ProfileID       uuid.UUID            `json:"profile_id"`
	ProfileName     string               `json:"profile_name"`
	ProfileImageUrl sql.NullString       `json:"profile_image_url"`
	ProfileEmail    string               `json:"profile_email"`
}

func (q *Queries) GetMembersByBusinessRootIDs(ctx context.Context, businessRootIds []uuid.UUID) ([]GetMembersByBusinessRootIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMembersByBusinessRootIDs, pq.Array(businessRootIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMembersByBusinessRootIDsRow
	for rows.Next() {
		var i GetMembersByBusinessRootIDsRow
		if err := rows.Scan(
			&i.BusinessRootID,
			&i.Status,
			&i.Role,
			&i.ProfileID,
			&i.ProfileName,
			&i.ProfileImageUrl,
			&i.ProfileEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

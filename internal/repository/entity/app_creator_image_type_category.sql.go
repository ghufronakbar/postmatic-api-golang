// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: app_creator_image_type_category.sql

package entity

import (
	"context"
)

const countAllAppCreatorImageTypeCategories = `-- name: CountAllAppCreatorImageTypeCategories :one
SELECT COUNT(*)::bigint AS total
FROM app_creator_image_type_categories t
WHERE
  $1 = ''
  OR t.name ILIKE ('%' || $1 || '%')
`

func (q *Queries) CountAllAppCreatorImageTypeCategories(ctx context.Context, search interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllAppCreatorImageTypeCategories, search)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getAllAppCreatorImageTypeCategories = `-- name: GetAllAppCreatorImageTypeCategories :many
WITH p0 AS (
  SELECT
    lower(COALESCE(NULLIF($3,  ''), '')) AS sb_in,
    lower(COALESCE(NULLIF($4, ''), '')) AS sd_in
),
p AS (
  SELECT
    CASE
      WHEN sb_in IN ('name', 'created_at', 'updated_at') THEN sb_in
      ELSE 'created_at'
    END AS sort_by,
    CASE
      WHEN sd_in IN ('asc', 'desc') THEN sd_in
      ELSE 'desc'
    END AS sort_dir
  FROM p0
),
q AS (
  SELECT
    t.id,
    t.name,
    t.created_at,
    t.updated_at,
    COUNT(DISTINCT citc.creator_image_id)::bigint AS total_data
  FROM app_creator_image_type_categories t
  LEFT JOIN creator_image_type_categories citc
    ON citc.type_category_id = t.id
  LEFT JOIN creator_images ci
    ON ci.id = citc.creator_image_id
   AND ci.deleted_at IS NULL
  WHERE
    $5 = ''
    OR t.name ILIKE ('%' || $5 || '%')
  GROUP BY t.id, t.name, t.created_at, t.updated_at
)
SELECT
  q.id,
  q.name,
  q.total_data
FROM q
CROSS JOIN p
ORDER BY
  -- name
  CASE WHEN p.sort_by = 'name' AND p.sort_dir = 'asc'  THEN q.name END ASC,
  CASE WHEN p.sort_by = 'name' AND p.sort_dir = 'desc' THEN q.name END DESC,

  -- created_at (default)
  CASE WHEN p.sort_by = 'created_at' AND p.sort_dir = 'asc'  THEN q.created_at END ASC,
  CASE WHEN p.sort_by = 'created_at' AND p.sort_dir = 'desc' THEN q.created_at END DESC,

  -- updated_at
  CASE WHEN p.sort_by = 'updated_at' AND p.sort_dir = 'asc'  THEN q.updated_at END ASC,
  CASE WHEN p.sort_by = 'updated_at' AND p.sort_dir = 'desc' THEN q.updated_at END DESC,

  -- fallback stable order
  q.created_at DESC,
  q.id DESC
LIMIT $2
OFFSET $1
`

type GetAllAppCreatorImageTypeCategoriesParams struct {
	PageOffset int32       `json:"page_offset"`
	PageLimit  int32       `json:"page_limit"`
	SortBy     interface{} `json:"sort_by"`
	SortDir    interface{} `json:"sort_dir"`
	Search     interface{} `json:"search"`
}

type GetAllAppCreatorImageTypeCategoriesRow struct {
	ID        int64  `json:"id"`
	Name      string `json:"name"`
	TotalData int64  `json:"total_data"`
}

func (q *Queries) GetAllAppCreatorImageTypeCategories(ctx context.Context, arg GetAllAppCreatorImageTypeCategoriesParams) ([]GetAllAppCreatorImageTypeCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAppCreatorImageTypeCategories,
		arg.PageOffset,
		arg.PageLimit,
		arg.SortBy,
		arg.SortDir,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAppCreatorImageTypeCategoriesRow
	for rows.Next() {
		var i GetAllAppCreatorImageTypeCategoriesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.TotalData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

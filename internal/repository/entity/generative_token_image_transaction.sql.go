// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: generative_token_image_transaction.sql

package entity

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const countAllTokenTransactionsByBusiness = `-- name: CountAllTokenTransactionsByBusiness :one
SELECT COUNT(*)::bigint AS total
FROM generative_token_image_transactions t
WHERE
    t.deleted_at IS NULL
    AND t.business_root_id = $1
    AND (
        $2::token_transaction_type IS NULL
        OR t.type = $2::token_transaction_type
    )
    AND (
        $3::date IS NULL
        OR t.created_at::date >= $3::date
    )
    AND (
        $4::date IS NULL
        OR t.created_at::date <= $4::date
    )
`

type CountAllTokenTransactionsByBusinessParams struct {
	BusinessRootID int64                    `json:"business_root_id"`
	Type           NullTokenTransactionType `json:"type"`
	DateStart      sql.NullTime             `json:"date_start"`
	DateEnd        sql.NullTime             `json:"date_end"`
}

func (q *Queries) CountAllTokenTransactionsByBusiness(ctx context.Context, arg CountAllTokenTransactionsByBusinessParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllTokenTransactionsByBusiness,
		arg.BusinessRootID,
		arg.Type,
		arg.DateStart,
		arg.DateEnd,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createGenerativeTokenImageTransaction = `-- name: CreateGenerativeTokenImageTransaction :one
INSERT INTO generative_token_image_transactions (
    type,
    amount,
    profile_id,
    business_root_id,
    payment_history_id
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, type, amount, profile_id, business_root_id, payment_history_id, created_at, updated_at, deleted_at
`

type CreateGenerativeTokenImageTransactionParams struct {
	Type             TokenTransactionType `json:"type"`
	Amount           int64                `json:"amount"`
	ProfileID        uuid.UUID            `json:"profile_id"`
	BusinessRootID   int64                `json:"business_root_id"`
	PaymentHistoryID uuid.NullUUID        `json:"payment_history_id"`
}

func (q *Queries) CreateGenerativeTokenImageTransaction(ctx context.Context, arg CreateGenerativeTokenImageTransactionParams) (GenerativeTokenImageTransaction, error) {
	row := q.db.QueryRowContext(ctx, createGenerativeTokenImageTransaction,
		arg.Type,
		arg.Amount,
		arg.ProfileID,
		arg.BusinessRootID,
		arg.PaymentHistoryID,
	)
	var i GenerativeTokenImageTransaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.PaymentHistoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAllTokenTransactionsByBusiness = `-- name: GetAllTokenTransactionsByBusiness :many
SELECT t.id, t.type, t.amount, t.profile_id, t.business_root_id, t.payment_history_id, t.created_at, t.updated_at, t.deleted_at
FROM generative_token_image_transactions t
WHERE
    t.deleted_at IS NULL
    AND t.business_root_id = $1
    AND (
        $2::token_transaction_type IS NULL
        OR t.type = $2::token_transaction_type
    )
    AND (
        $3::date IS NULL
        OR t.created_at::date >= $3::date
    )
    AND (
        $4::date IS NULL
        OR t.created_at::date <= $4::date
    )
ORDER BY
    CASE WHEN $5 = 'id' AND $6 = 'asc' THEN t.id END ASC,
    CASE WHEN $5 = 'id' AND $6 = 'desc' THEN t.id END DESC,
    CASE WHEN $5 = 'created_at' AND $6 = 'asc' THEN t.created_at END ASC,
    CASE WHEN $5 = 'created_at' AND $6 = 'desc' THEN t.created_at END DESC,
    CASE WHEN $5 = 'amount' AND $6 = 'asc' THEN t.amount END ASC,
    CASE WHEN $5 = 'amount' AND $6 = 'desc' THEN t.amount END DESC,
    t.id DESC
LIMIT $8
OFFSET $7
`

type GetAllTokenTransactionsByBusinessParams struct {
	BusinessRootID int64                    `json:"business_root_id"`
	Type           NullTokenTransactionType `json:"type"`
	DateStart      sql.NullTime             `json:"date_start"`
	DateEnd        sql.NullTime             `json:"date_end"`
	SortBy         interface{}              `json:"sort_by"`
	SortDir        interface{}              `json:"sort_dir"`
	PageOffset     int32                    `json:"page_offset"`
	PageLimit      int32                    `json:"page_limit"`
}

func (q *Queries) GetAllTokenTransactionsByBusiness(ctx context.Context, arg GetAllTokenTransactionsByBusinessParams) ([]GenerativeTokenImageTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getAllTokenTransactionsByBusiness,
		arg.BusinessRootID,
		arg.Type,
		arg.DateStart,
		arg.DateEnd,
		arg.SortBy,
		arg.SortDir,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GenerativeTokenImageTransaction
	for rows.Next() {
		var i GenerativeTokenImageTransaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Amount,
			&i.ProfileID,
			&i.BusinessRootID,
			&i.PaymentHistoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenerativeTokenImageTransactionByPaymentHistoryId = `-- name: GetGenerativeTokenImageTransactionByPaymentHistoryId :one
SELECT id, type, amount, profile_id, business_root_id, payment_history_id, created_at, updated_at, deleted_at FROM generative_token_image_transactions
WHERE payment_history_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetGenerativeTokenImageTransactionByPaymentHistoryId(ctx context.Context, paymentHistoryID uuid.NullUUID) (GenerativeTokenImageTransaction, error) {
	row := q.db.QueryRowContext(ctx, getGenerativeTokenImageTransactionByPaymentHistoryId, paymentHistoryID)
	var i GenerativeTokenImageTransaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.PaymentHistoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSuccessPaymentIdsWithoutTokenTransaction = `-- name: GetSuccessPaymentIdsWithoutTokenTransaction :many
SELECT ph.id, ph.profile_id, ph.business_root_id, ph.product_amount
FROM payment_histories ph
LEFT JOIN generative_token_image_transactions gt 
    ON gt.payment_history_id = ph.id AND gt.deleted_at IS NULL
WHERE 
    ph.id = ANY($1::uuid[])
    AND ph.status = 'success'
    AND ph.deleted_at IS NULL
    AND gt.id IS NULL
`

type GetSuccessPaymentIdsWithoutTokenTransactionRow struct {
	ID             uuid.UUID `json:"id"`
	ProfileID      uuid.UUID `json:"profile_id"`
	BusinessRootID int64     `json:"business_root_id"`
	ProductAmount  int64     `json:"product_amount"`
}

func (q *Queries) GetSuccessPaymentIdsWithoutTokenTransaction(ctx context.Context, paymentIds []uuid.UUID) ([]GetSuccessPaymentIdsWithoutTokenTransactionRow, error) {
	rows, err := q.db.QueryContext(ctx, getSuccessPaymentIdsWithoutTokenTransaction, pq.Array(paymentIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSuccessPaymentIdsWithoutTokenTransactionRow
	for rows.Next() {
		var i GetSuccessPaymentIdsWithoutTokenTransactionRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.BusinessRootID,
			&i.ProductAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumTokenByBusinessAndType = `-- name: SumTokenByBusinessAndType :one
SELECT 
    COALESCE(SUM(amount), 0)::bigint AS total
FROM generative_token_image_transactions
WHERE 
    business_root_id = $1 
    AND type = $2
    AND deleted_at IS NULL
`

type SumTokenByBusinessAndTypeParams struct {
	BusinessRootID int64                `json:"business_root_id"`
	Type           TokenTransactionType `json:"type"`
}

func (q *Queries) SumTokenByBusinessAndType(ctx context.Context, arg SumTokenByBusinessAndTypeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, sumTokenByBusinessAndType, arg.BusinessRootID, arg.Type)
	var total int64
	err := row.Scan(&total)
	return total, err
}

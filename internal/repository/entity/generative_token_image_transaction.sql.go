// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: generative_token_image_transaction.sql

package entity

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createGenerativeTokenImageTransaction = `-- name: CreateGenerativeTokenImageTransaction :one
INSERT INTO generative_token_image_transactions (
    type,
    amount,
    profile_id,
    business_root_id,
    payment_history_id
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, type, amount, profile_id, business_root_id, payment_history_id, created_at, updated_at, deleted_at
`

type CreateGenerativeTokenImageTransactionParams struct {
	Type             TokenTransactionType `json:"type"`
	Amount           int64                `json:"amount"`
	ProfileID        uuid.UUID            `json:"profile_id"`
	BusinessRootID   int64                `json:"business_root_id"`
	PaymentHistoryID uuid.NullUUID        `json:"payment_history_id"`
}

func (q *Queries) CreateGenerativeTokenImageTransaction(ctx context.Context, arg CreateGenerativeTokenImageTransactionParams) (GenerativeTokenImageTransaction, error) {
	row := q.db.QueryRowContext(ctx, createGenerativeTokenImageTransaction,
		arg.Type,
		arg.Amount,
		arg.ProfileID,
		arg.BusinessRootID,
		arg.PaymentHistoryID,
	)
	var i GenerativeTokenImageTransaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.PaymentHistoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getGenerativeTokenImageTransactionByPaymentHistoryId = `-- name: GetGenerativeTokenImageTransactionByPaymentHistoryId :one
SELECT id, type, amount, profile_id, business_root_id, payment_history_id, created_at, updated_at, deleted_at FROM generative_token_image_transactions
WHERE payment_history_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetGenerativeTokenImageTransactionByPaymentHistoryId(ctx context.Context, paymentHistoryID uuid.NullUUID) (GenerativeTokenImageTransaction, error) {
	row := q.db.QueryRowContext(ctx, getGenerativeTokenImageTransactionByPaymentHistoryId, paymentHistoryID)
	var i GenerativeTokenImageTransaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.ProfileID,
		&i.BusinessRootID,
		&i.PaymentHistoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSuccessPaymentIdsWithoutTokenTransaction = `-- name: GetSuccessPaymentIdsWithoutTokenTransaction :many
SELECT ph.id, ph.profile_id, ph.business_root_id, ph.product_amount
FROM payment_histories ph
LEFT JOIN generative_token_image_transactions gt 
    ON gt.payment_history_id = ph.id AND gt.deleted_at IS NULL
WHERE 
    ph.id = ANY($1::uuid[])
    AND ph.status = 'success'
    AND ph.deleted_at IS NULL
    AND gt.id IS NULL
`

type GetSuccessPaymentIdsWithoutTokenTransactionRow struct {
	ID             uuid.UUID `json:"id"`
	ProfileID      uuid.UUID `json:"profile_id"`
	BusinessRootID int64     `json:"business_root_id"`
	ProductAmount  int64     `json:"product_amount"`
}

func (q *Queries) GetSuccessPaymentIdsWithoutTokenTransaction(ctx context.Context, paymentIds []uuid.UUID) ([]GetSuccessPaymentIdsWithoutTokenTransactionRow, error) {
	rows, err := q.db.QueryContext(ctx, getSuccessPaymentIdsWithoutTokenTransaction, pq.Array(paymentIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSuccessPaymentIdsWithoutTokenTransactionRow
	for rows.Next() {
		var i GetSuccessPaymentIdsWithoutTokenTransactionRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.BusinessRootID,
			&i.ProductAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumTokenByBusinessAndType = `-- name: SumTokenByBusinessAndType :one
SELECT 
    COALESCE(SUM(amount), 0)::bigint AS total
FROM generative_token_image_transactions
WHERE 
    business_root_id = $1 
    AND type = $2
    AND deleted_at IS NULL
`

type SumTokenByBusinessAndTypeParams struct {
	BusinessRootID int64                `json:"business_root_id"`
	Type           TokenTransactionType `json:"type"`
}

func (q *Queries) SumTokenByBusinessAndType(ctx context.Context, arg SumTokenByBusinessAndTypeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, sumTokenByBusinessAndType, arg.BusinessRootID, arg.Type)
	var total int64
	err := row.Scan(&total)
	return total, err
}

-- AUTO-GENERATED by schema.sh
-- Generated at: 2026-01-18T15:53:03Z
-- Source: migrations/*.sql

-- =====================================================================
-- SOURCE: 20251214120953_init_extension.sql
-- =====================================================================

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;



-- =====================================================================
-- SOURCE: 20251214121038_create_users_profiles_table.sql
-- =====================================================================


CREATE TYPE auth_provider AS ENUM ('google', 'credential');
CREATE TABLE IF NOT EXISTS profiles (
    -- Tambahkan DEFAULT gen_random_uuid()
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(), 
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,

    -- Gunakan sql.NullString di Go nantinya
    image_url VARCHAR(255),
    country_code VARCHAR(4),
    phone VARCHAR(20),
    description TEXT,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP

);

CREATE TRIGGER trigger_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    password VARCHAR(255),
    provider auth_provider NOT NULL,
    verified_at TIMESTAMPTZ,

    -- Tambahkan NOT NULL agar di Go tipenya uuid.UUID (bukan NullUUID)
    profile_id UUID NOT NULL, 
    FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP

);

CREATE TRIGGER trigger_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();




-- =====================================================================
-- SOURCE: 20251218125633_create_business_bknowledge_bproduct_brole_brsssubscription.sql
-- =====================================================================

CREATE TABLE IF NOT EXISTS business_roots ( 
    id BIGSERIAL PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- 1 to 1 with business_root
CREATE TABLE IF NOT EXISTS business_knowledges ( 
    id BIGSERIAL PRIMARY KEY,

    name VARCHAR(255) NOT NULL,
    primary_logo_url VARCHAR(255),
    category VARCHAR(255) NOT NULL,
    description TEXT,

    unique_selling_point TEXT,
    website_url VARCHAR(255),
    vision_mission TEXT,
    location VARCHAR(255),
    color_tone VARCHAR(6),

    business_root_id BIGINT NOT NULL UNIQUE,
    FOREIGN KEY (business_root_id) REFERENCES business_roots(id) ON DELETE CASCADE,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- 1 to many with business_root
CREATE TABLE IF NOT EXISTS business_products ( 
    id BIGSERIAL PRIMARY KEY,

    name VARCHAR(255) NOT NULL,
    category VARCHAR(255) NOT NULL,
    description TEXT,

    currency CHAR(3) NOT NULL,
    price BIGINT NOT NULL,

    image_urls VARCHAR(255)[] NOT NULL,

    business_root_id BIGINT NOT NULL,
    FOREIGN KEY (business_root_id) REFERENCES business_roots(id) ON DELETE CASCADE,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- 1 to 1 with business_root
CREATE TABLE IF NOT EXISTS business_roles ( 
    id BIGSERIAL PRIMARY KEY,

    target_audience VARCHAR(255) NOT NULL,
    tone VARCHAR(255) NOT NULL,
    audience_persona VARCHAR(255) NOT NULL,
    hashtags VARCHAR(255)[] NOT NULL,
    call_to_action VARCHAR(255) NOT NULL,
    goals TEXT,

    business_root_id BIGINT NOT NULL UNIQUE,
    FOREIGN KEY (business_root_id) REFERENCES business_roots(id) ON DELETE CASCADE,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- 1 to many with business_root
CREATE TABLE IF NOT EXISTS business_rss_subscriptions ( 
    id BIGSERIAL PRIMARY KEY,

    title VARCHAR(255) NOT NULL,
    is_active BOOLEAN NOT NULL,

    business_root_id BIGINT NOT NULL,
    FOREIGN KEY (business_root_id) REFERENCES business_roots(id) ON DELETE CASCADE,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Func for trigger root
CREATE OR REPLACE FUNCTION touch_business_root_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE business_roots
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = NEW.business_root_id;

    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    -- Kalau pindah root, touch root lama juga
    IF OLD.business_root_id IS DISTINCT FROM NEW.business_root_id THEN
      UPDATE business_roots
      SET updated_at = CURRENT_TIMESTAMP
      WHERE id = OLD.business_root_id;
    END IF;

    UPDATE business_roots
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = NEW.business_root_id;

    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    UPDATE business_roots
    SET updated_at = CURRENT_TIMESTAMP
    WHERE id = OLD.business_root_id;

    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger Each Table

CREATE TRIGGER trg_business_roots_set_updated_at
BEFORE UPDATE ON business_roots
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_business_knowledges_set_updated_at
BEFORE UPDATE ON business_knowledges
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_business_products_set_updated_at
BEFORE UPDATE ON business_products
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_business_roles_set_updated_at
BEFORE UPDATE ON business_roles
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_business_rss_subscriptions_set_updated_at
BEFORE UPDATE ON business_rss_subscriptions
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- Trigger For Root
CREATE TRIGGER trg_touch_root_from_knowledges
AFTER INSERT OR UPDATE OR DELETE ON business_knowledges
FOR EACH ROW
EXECUTE FUNCTION touch_business_root_updated_at();

CREATE TRIGGER trg_touch_root_from_products
AFTER INSERT OR UPDATE OR DELETE ON business_products
FOR EACH ROW
EXECUTE FUNCTION touch_business_root_updated_at();

CREATE TRIGGER trg_touch_root_from_roles
AFTER INSERT OR UPDATE OR DELETE ON business_roles
FOR EACH ROW
EXECUTE FUNCTION touch_business_root_updated_at();

CREATE TRIGGER trg_touch_root_from_rss_subscriptions
AFTER INSERT OR UPDATE OR DELETE ON business_rss_subscriptions
FOR EACH ROW
EXECUTE FUNCTION touch_business_root_updated_at();





-- =====================================================================
-- SOURCE: 20251218133145_create_members_table.sql
-- =====================================================================


-- Enums (idempotent)
CREATE TYPE business_member_status AS ENUM ('pending', 'accepted', 'rejected', 'left', 'kicked');
CREATE TYPE business_member_role AS ENUM ('owner', 'admin', 'member');

-- Members
CREATE TABLE IF NOT EXISTS business_members (
    id BIGSERIAL PRIMARY KEY,

    status business_member_status NOT NULL,
    role   business_member_role   NOT NULL,
    answered_at TIMESTAMPTZ,

    business_root_id BIGINT NOT NULL,
    profile_id       UUID NOT NULL,

    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,

    CONSTRAINT business_members_root_profile_unique UNIQUE (business_root_id, profile_id),

    FOREIGN KEY (business_root_id) REFERENCES business_roots(id) ON DELETE CASCADE,
    FOREIGN KEY (profile_id)       REFERENCES profiles(id)       ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_business_members_business_root_id
  ON business_members(business_root_id);

CREATE INDEX IF NOT EXISTS idx_business_members_profile_id
  ON business_members(profile_id);

DROP TRIGGER IF EXISTS trigger_business_members_updated_at ON business_members;
CREATE TRIGGER trigger_business_members_updated_at
BEFORE UPDATE ON business_members
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- Status histories
CREATE TABLE IF NOT EXISTS business_member_status_histories (
    id BIGSERIAL PRIMARY KEY,

    status business_member_status NOT NULL,
    role   business_member_role   NOT NULL,
    member_id BIGINT NOT NULL,

    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ,

    FOREIGN KEY (member_id) REFERENCES business_members(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_business_member_status_histories_member_id
  ON business_member_status_histories(member_id);

DROP TRIGGER IF EXISTS trigger_business_member_status_histories_updated_at
  ON business_member_status_histories;

CREATE TRIGGER trigger_business_member_status_histories_updated_at
BEFORE UPDATE ON business_member_status_histories
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();





-- =====================================================================
-- SOURCE: 20251221135856_create_uploaded_images_table.sql
-- =====================================================================

CREATE TYPE image_provider AS ENUM ('cloudinary');

CREATE TABLE uploaded_images (
    id BIGSERIAL PRIMARY KEY,
    hashkey VARCHAR(255) NOT NULL UNIQUE,
    public_id VARCHAR(255) NOT NULL,
    size BIGINT NOT NULL,
    image_url VARCHAR(255) NOT NULL,
    provider image_provider NOT NULL,
    format VARCHAR(8) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);




-- =====================================================================
-- SOURCE: 20251225112121_create_app_rss_app_rss_category_table.sql
-- =====================================================================

CREATE TABLE app_rss_categories (
	id BIGSERIAL PRIMARY KEY,
	name VARCHAR(255) NOT NULL,
	deleted_at TIMESTAMPTZ,
	created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trigger_app_rss_categories_updated_at
BEFORE UPDATE ON app_rss_categories
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TABLE app_rss_feeds (
	id BIGSERIAL PRIMARY KEY,
	title VARCHAR(255) NOT NULL,
	url VARCHAR(255) NOT NULL,
	publisher VARCHAR(255) NOT NULL,
	app_rss_category_id BIGINT NOT NULL,
	FOREIGN KEY (app_rss_category_id) REFERENCES app_rss_categories(id),
	deleted_at TIMESTAMPTZ,
	created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trigger_app_rss_feeds_updated_at
BEFORE UPDATE ON app_rss_feeds
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();



-- =====================================================================
-- SOURCE: 20251225123316_alter_business_rss_subscriptions_table.sql
-- =====================================================================

-- Relasi: business_rss_subscriptions (*) -> app_rss_feeds (1)

ALTER TABLE business_rss_subscriptions
ADD COLUMN IF NOT EXISTS app_rss_feed_id BIGINT NOT NULL;

ALTER TABLE business_rss_subscriptions
ADD CONSTRAINT fk_business_rss_subscriptions_app_rss_feed_id
FOREIGN KEY (app_rss_feed_id)
REFERENCES app_rss_feeds(id)
ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_business_rss_subscriptions_app_rss_feed_id
ON business_rss_subscriptions(app_rss_feed_id);



-- =====================================================================
-- SOURCE: 20251225211811_create_business_timezone_prefs_table.sql
-- =====================================================================

-- 1 to 1 with business_roots(id)
CREATE TABLE IF NOT EXISTS business_timezone_prefs (
	id SERIAL PRIMARY KEY,
	business_root_id BIGSERIAL NOT NULL UNIQUE,
    FOREIGN KEY (business_root_id) REFERENCES business_roots (id) ON DELETE CASCADE,
	timezone VARCHAR(255) NOT NULL DEFAULT 'Asia/Jakarta',
	created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
CREATE TRIGGER trg_business_timezone_prefs_set_updated_at
BEFORE UPDATE ON business_timezone_prefs
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_touch_root_from_timezone_prefs
AFTER INSERT OR UPDATE OR DELETE ON business_timezone_prefs
FOR EACH ROW
EXECUTE FUNCTION touch_business_root_updated_at();



-- =====================================================================
-- SOURCE: 20251226135819_create_creator_images_and_app_creator_image_type_categories_and_app_creator_image_product_categories_table.sql
-- =====================================================================


-- ex: announcement, entertainment, marketing, etc
CREATE TABLE IF NOT EXISTS app_creator_image_type_categories (
	id BIGSERIAL PRIMARY KEY,
	name VARCHAR(255) NOT NULL,
	created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trigger_app_creator_image_type_categories_updated_at
BEFORE UPDATE ON app_creator_image_type_categories
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- ex: fashion & lifestyle, makanan & minuman, etc
CREATE TABLE IF NOT EXISTS app_creator_image_product_categories (
	id BIGSERIAL PRIMARY KEY,
    indonesian_name VARCHAR(255) NOT NULL,
    english_name VARCHAR(255) NOT NULL,
	created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trigger_app_creator_image_product_categories_updated_at
BEFORE UPDATE ON app_creator_image_product_categories
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();


-- base table (tanpa FK category)
CREATE TABLE IF NOT EXISTS creator_images (
	id BIGSERIAL PRIMARY KEY,
	name VARCHAR(255) NOT NULL,
	image_url TEXT NOT NULL,
    is_published BOOLEAN NOT NULL DEFAULT FALSE,
    is_banned BOOLEAN NOT NULL DEFAULT FALSE,
    banned_reason TEXT,
    price BIGINT NOT NULL,

	-- creator profile (if null -> template from app/postmatic)
	profile_id UUID,
    CONSTRAINT fk_creator_images_profile
		FOREIGN KEY (profile_id) REFERENCES profiles(id),

	created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
	deleted_at TIMESTAMPTZ
);

CREATE TRIGGER trigger_creator_images_updated_at
BEFORE UPDATE ON creator_images
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();


-- pivot: creator_images <-> product categories
CREATE TABLE IF NOT EXISTS creator_image_product_categories (
	creator_image_id BIGINT NOT NULL,
	product_category_id BIGINT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

	CONSTRAINT pk_creator_image_product_categories
		PRIMARY KEY (creator_image_id, product_category_id),

	CONSTRAINT fk_cipc_creator_image
		FOREIGN KEY (creator_image_id) REFERENCES creator_images(id) ON DELETE CASCADE,

	-- biasanya NO ACTION/RESTRICT biar category tidak bisa dihapus kalau masih dipakai
	CONSTRAINT fk_cipc_product_category
		FOREIGN KEY (product_category_id) REFERENCES app_creator_image_product_categories(id)
);

CREATE INDEX IF NOT EXISTS idx_cipc_creator_image_id
	ON creator_image_product_categories(creator_image_id);

CREATE INDEX IF NOT EXISTS idx_cipc_product_category_id
	ON creator_image_product_categories(product_category_id);


-- pivot: creator_images <-> type categories
CREATE TABLE IF NOT EXISTS creator_image_type_categories (
	creator_image_id BIGINT NOT NULL,
	type_category_id BIGINT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

	CONSTRAINT pk_creator_image_type_categories
		PRIMARY KEY (creator_image_id, type_category_id),

	CONSTRAINT fk_citc_creator_image
		FOREIGN KEY (creator_image_id) REFERENCES creator_images(id) ON DELETE CASCADE,

	CONSTRAINT fk_citc_type_category
		FOREIGN KEY (type_category_id) REFERENCES app_creator_image_type_categories(id)
);

CREATE INDEX IF NOT EXISTS idx_citc_creator_image_id
	ON creator_image_type_categories(creator_image_id);

CREATE INDEX IF NOT EXISTS idx_citc_type_category_id
	ON creator_image_type_categories(type_category_id);





-- =====================================================================
-- SOURCE: 20251227121443_alter_uploaded_images_add_s3.sql
-- =====================================================================

ALTER TYPE image_provider ADD VALUE IF NOT EXISTS 's3';



-- =====================================================================
-- SOURCE: 20251230162912_create_business_image_contents_table.sql
-- =====================================================================

CREATE TYPE business_image_content_type   AS ENUM ('personal', 'generated');

-- 1 to many with business_root_id
-- many to one with business_product_id (nullable)
CREATE TABLE IF NOT EXISTS business_image_contents (
	id BIGSERIAL PRIMARY KEY,
    image_urls VARCHAR(255)[] NOT NULL,
    caption TEXT,
    type business_image_content_type NOT NULL,
    ready_to_post BOOLEAN NOT NULL,
    category VARCHAR(255) NOT NULL,

    business_product_id BIGINT NULL,
    FOREIGN KEY (business_product_id) REFERENCES business_products (id) ON DELETE CASCADE,

	business_root_id BIGSERIAL NOT NULL,
    FOREIGN KEY (business_root_id) REFERENCES business_roots (id) ON DELETE CASCADE,

	created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);
CREATE TRIGGER trg_business_image_contents_set_updated_at
BEFORE UPDATE ON business_image_contents
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();



-- =====================================================================
-- SOURCE: 20260101161623_trigger_business_member_invitation_histories_to_updated_at_member_histories.sql
-- =====================================================================


CREATE OR REPLACE FUNCTION fn_touch_business_member_updated_at_from_status_history()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE business_members AS bm
  SET updated_at = CURRENT_TIMESTAMP
  WHERE bm.id = NEW.member_id
    AND bm.deleted_at IS NULL;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_touch_business_member_updated_at_from_status_history
ON business_member_status_histories;

CREATE TRIGGER trg_touch_business_member_updated_at_from_status_history
AFTER INSERT ON business_member_status_histories
FOR EACH ROW
EXECUTE FUNCTION fn_touch_business_member_updated_at_from_status_history();





-- =====================================================================
-- SOURCE: 20260101162042_alter_type_business_member_status.sql
-- =====================================================================

ALTER TYPE business_member_status ADD VALUE IF NOT EXISTS 'expired';



-- =====================================================================
-- SOURCE: 20260102141123_create_type_app_role_alter_profile.sql
-- =====================================================================

CREATE TYPE app_role AS ENUM ('admin', 'user');

ALTER TABLE profiles
ADD COLUMN role app_role NOT NULL DEFAULT 'user';




-- =====================================================================
-- SOURCE: 20260102153913_create_app_profile_referral_rules_table.sql
-- =====================================================================


-- ENUM (idempotent)
CREATE TYPE discount_type AS ENUM ('fixed', 'percentage');


-- EXPECTED ONLY 1 ROW (APP RULES)
CREATE TABLE IF NOT EXISTS app_profile_referral_rules (
  id smallint PRIMARY KEY DEFAULT 1 CHECK (id = 1),

  -- CONSUMER
  -- ex: Rp 10.000 or 10%
  total_discount BIGINT NOT NULL DEFAULT 0,
  discount_type discount_type NOT NULL DEFAULT 'fixed',
  -- if null there is no expiration
  expired_days INT,
  -- max discount for consumer
  max_discount BIGINT NOT NULL DEFAULT 0,
  -- max usage for consumer, if null there is no limit
  max_usage INT,

  -- PRODUCER
  -- ex: Rp 10.000
  reward_per_referral BIGINT NOT NULL DEFAULT 0,

  created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,

  -- optional sanity checks
  CONSTRAINT app_profile_referral_rules_total_discount_nonneg CHECK (total_discount >= 0),
  CONSTRAINT app_profile_referral_rules_max_discount_nonneg  CHECK (max_discount >= 0),
  CONSTRAINT app_profile_referral_rules_reward_nonneg        CHECK (reward_per_referral >= 0),
  CONSTRAINT app_profile_referral_rules_expired_days_pos     CHECK (expired_days IS NULL OR expired_days > 0),
  CONSTRAINT app_profile_referral_rules_max_usage_pos        CHECK (max_usage IS NULL OR max_usage > 0)
);

CREATE TRIGGER trigger_app_profile_referral_rules_updated_at
BEFORE UPDATE ON app_profile_referral_rules
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- seed singleton row
INSERT INTO app_profile_referral_rules (id)
VALUES (1)
ON CONFLICT (id) DO NOTHING;

-- AUDIT / CHANGES (biasanya INSERT-only)
CREATE TABLE IF NOT EXISTS app_profile_referral_changes (
  id BIGSERIAL PRIMARY KEY,

  -- who made the change
  profile_id UUID NOT NULL,
  FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE RESTRICT,

  -- snapshot of rules
  total_discount BIGINT NOT NULL,
  discount_type discount_type NOT NULL,
  expired_days INT,
  max_discount BIGINT NOT NULL,
  max_usage INT,
  reward_per_referral BIGINT NOT NULL,

  created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trigger_app_profile_referral_changes_updated_at
BEFORE UPDATE ON app_profile_referral_changes
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- trigger: when changes inserted/updated, touch rules.updated_at
CREATE OR REPLACE FUNCTION touch_app_profile_referral_rules_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE app_profile_referral_rules
  SET updated_at = now()
  WHERE id = 1;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_touch_app_profile_referral_rules_updated_at
AFTER INSERT OR UPDATE ON app_profile_referral_changes
FOR EACH ROW
EXECUTE FUNCTION touch_app_profile_referral_rules_updated_at();




-- =====================================================================
-- SOURCE: 20260102173819_create_profile_referral_codes.sql
-- =====================================================================

-- every user has 1 basic referral code (created by system)
-- special referral code can be created by admin
CREATE TYPE referral_type AS ENUM ('basic', 'special');
CREATE TABLE IF NOT EXISTS profile_referral_codes (
    id BIGSERIAL PRIMARY KEY,
    -- user that has created the referral code
    profile_id UUID NOT NULL,
    FOREIGN KEY (profile_id) REFERENCES profiles (id),
    -- unique code to consumer use
    code VARCHAR(255) NOT NULL UNIQUE,
    type referral_type NOT NULL,
    is_active BOOLEAN NOT NULL,

    -- DENORMALIZED FOR RECORD
    -- CONSUMER
    -- ex: Rp 10.000 or 10%
    total_discount BIGINT NOT NULL DEFAULT 0,
    discount_type discount_type NOT NULL DEFAULT 'fixed',
    -- if null there is no expiration
    expired_days INT,
    -- max discount for consumer
    max_discount BIGINT NOT NULL DEFAULT 0,
    -- max usage for consumer, if null there is no limit
    max_usage INT,

    -- PRODUCER
    -- ex: Rp 10.000
    reward_per_referral BIGINT NOT NULL DEFAULT 0,

    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);
CREATE TRIGGER trigger_profile_referral_codes_updated_at
BEFORE UPDATE ON profile_referral_codes
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE UNIQUE INDEX IF NOT EXISTS uq_profile_one_basic
ON profile_referral_codes (profile_id)
WHERE type = 'basic' AND deleted_at IS NULL;




-- =====================================================================
-- SOURCE: 20260106163450_create_app_token_products_table.sql
-- =====================================================================


-- ENUM (idempotent)
CREATE TYPE token_type AS ENUM ('image_token', 'video_token', 'livestream_token');


CREATE TABLE IF NOT EXISTS app_token_products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  token_type token_type NOT NULL,
--   ex: IDR, USD, etc
  currency_code VARCHAR(3) NOT NULL,
--   ex: Rp 1000
  price_amount BIGINT NOT NULL,
--   ex: 833 tokens
  token_amount BIGINT NOT NULL,
  is_active BOOLEAN NOT NULL,
  sort_order INT NOT NULL,

  created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  deleted_at TIMESTAMPTZ

  -- sanity checks
  CONSTRAINT app_token_products_price_positive CHECK (price_amount > 0),
  CONSTRAINT app_token_products_token_positive CHECK (token_amount > 0),
  CONSTRAINT app_token_products_currency_len CHECK (char_length(currency_code) = 3),
  CONSTRAINT app_token_products_currency_upper CHECK (currency_code = UPPER(currency_code))
);

CREATE TRIGGER trigger_app_token_products_updated_at
BEFORE UPDATE ON app_token_products
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- seed first row
INSERT INTO app_token_products (id, token_type, currency_code, price_amount, token_amount, is_active, sort_order)
VALUES ('c977673c-910c-4217-b451-b98724558016', 'image_token', 'IDR', 1000, 833, TRUE, 1)
ON CONFLICT (id) DO NOTHING;
-- for the first time, no need to insert to changes table

-- AUDIT / CHANGES (biasanya INSERT-only)
CREATE TABLE IF NOT EXISTS app_token_product_changes (
  id BIGSERIAL PRIMARY KEY,

  -- who made the change
  profile_id UUID NOT NULL,
  FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE RESTRICT,

  -- snapshot of product
  token_type token_type NOT NULL,
  currency_code VARCHAR(3) NOT NULL,
  price_amount BIGINT NOT NULL,
  token_amount BIGINT NOT NULL,
  is_active BOOLEAN NOT NULL,
  sort_order INT NOT NULL,

  created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trigger_app_token_product_changes_updated_at
BEFORE UPDATE ON app_token_product_changes
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();




-- =====================================================================
-- SOURCE: 20260117074156_create_app_payment_methods_table.sql
-- =====================================================================


CREATE TYPE action_change_type AS ENUM ('create', 'update', 'delete');

CREATE TYPE app_payment_admin_type AS ENUM ('fixed', 'percentage');
CREATE TYPE app_payment_method_type AS ENUM ('bank', 'ewallet');
CREATE TABLE IF NOT EXISTS app_payment_methods (
    id BIGSERIAL PRIMARY KEY,
    code VARCHAR(20) NOT NULL,

    -- information
    name VARCHAR(255) NOT NULL,
    type app_payment_method_type NOT NULL,
    image VARCHAR(255),

    -- functional
    -- tax must be percentage (0-100)
    tax_fee BIGINT NOT NULL,
    -- admin fee can be fixed or percentage
    admin_type app_payment_admin_type NOT NULL,
    admin_fee BIGINT NOT NULL,
    -- switch active state
    is_active BOOLEAN NOT NULL,

    -- timestamp
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);

CREATE UNIQUE INDEX app_payment_methods_code_key 
ON app_payment_methods (code) 
WHERE deleted_at IS NULL;

CREATE TRIGGER trigger_app_payment_methods_updated_at
BEFORE UPDATE ON app_payment_methods
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TABLE IF NOT EXISTS app_payment_method_changes (
    id BIGSERIAL PRIMARY KEY,
    action action_change_type NOT NULL,

    -- actioner (for seeder no need to input this)
    profile_id UUID NOT NULL,
    FOREIGN KEY (profile_id) REFERENCES profiles (id),

    -- payment method that has been changed
    payment_method_id BIGINT NOT NULL,
    FOREIGN KEY (payment_method_id) REFERENCES app_payment_methods (id),

    -- before (jika create, before = after)
    before_code VARCHAR(20) NOT NULL,
    before_name VARCHAR(255) NOT NULL,
    before_type app_payment_method_type NOT NULL,
    before_image VARCHAR(255),
    before_admin_type app_payment_admin_type NOT NULL,
    before_admin_fee BIGINT NOT NULL,
    before_tax_fee BIGINT NOT NULL,
    before_is_active BOOLEAN NOT NULL,

    -- after
    after_code VARCHAR(20) NOT NULL,
    after_name VARCHAR(255) NOT NULL,
    after_type app_payment_method_type NOT NULL,
    after_image VARCHAR(255),
    after_admin_type app_payment_admin_type NOT NULL,
    after_admin_fee BIGINT NOT NULL,
    after_tax_fee BIGINT NOT NULL,
    after_is_active BOOLEAN NOT NULL,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);
CREATE TRIGGER trigger_app_payment_method_changes_updated_at
BEFORE UPDATE ON app_payment_method_changes
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- trigger: when changes inserted/updated, touch rules.updated_at
CREATE OR REPLACE FUNCTION touch_app_payment_method_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE app_payment_methods
  SET updated_at = now()
  WHERE id = NEW.payment_method_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_touch_app_payment_method_updated_at
AFTER INSERT OR UPDATE ON app_payment_method_changes
FOR EACH ROW
EXECUTE FUNCTION touch_app_payment_method_updated_at();



-- =====================================================================
-- SOURCE: 20260117150840_create_app_generative_image_models_table.sql
-- =====================================================================

CREATE TYPE app_generative_image_model_provider_type AS ENUM ('openai', 'google');
CREATE TABLE IF NOT EXISTS app_generative_image_models (
    id BIGSERIAL PRIMARY KEY,
    -- ex: "gpt-image-1" UNIQUE (partial with deleted)
    model VARCHAR(255) NOT NULL,

    -- information
    -- ex:"GPT Image 1"
    label VARCHAR(255) NOT NULL,
    image VARCHAR(255),

    -- functional
    -- provider (for switch case generate image)
    provider app_generative_image_model_provider_type NOT NULL,
    -- switch active state
    is_active BOOLEAN NOT NULL,
    -- valid rations (string[])
    valid_ratios TEXT[] NOT NULL,
    -- image_sizes (string[]), if null: models are not supported image sizes
    image_sizes TEXT[],
    

    -- timestamp
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);

CREATE UNIQUE INDEX app_generative_image_models_model_key 
ON app_generative_image_models (model) 
WHERE deleted_at IS NULL;

CREATE TRIGGER trigger_app_generative_image_models_updated_at
BEFORE UPDATE ON app_generative_image_models
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

CREATE TABLE IF NOT EXISTS app_generative_image_model_changes (
    id BIGSERIAL PRIMARY KEY,
    action action_change_type NOT NULL,

    -- actioner (for seeder no need to input this)
    profile_id UUID NOT NULL,
    FOREIGN KEY (profile_id) REFERENCES profiles (id),

    -- generative image model that has been changed
    generative_image_model_id BIGINT NOT NULL,
    FOREIGN KEY (generative_image_model_id) REFERENCES app_generative_image_models (id),

    -- before (jika create, before = after)
    before_model VARCHAR(255) NOT NULL,
    before_label VARCHAR(255) NOT NULL,
    before_image VARCHAR(255),
    before_provider app_generative_image_model_provider_type NOT NULL,
    before_is_active BOOLEAN NOT NULL,
    before_valid_ratios TEXT[] NOT NULL,
    before_image_sizes TEXT[],

    -- after
    after_model VARCHAR(255) NOT NULL,
    after_label VARCHAR(255) NOT NULL,
    after_image VARCHAR(255),
    after_provider app_generative_image_model_provider_type NOT NULL,
    after_is_active BOOLEAN NOT NULL,
    after_valid_ratios TEXT[] NOT NULL,
    after_image_sizes TEXT[],
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);
CREATE TRIGGER trigger_app_generative_image_model_changes_updated_at
BEFORE UPDATE ON app_generative_image_model_changes
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- trigger: when changes inserted/updated, touch rules.updated_at
CREATE OR REPLACE FUNCTION touch_app_generative_image_model_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE app_generative_image_models
  SET updated_at = now()
  WHERE id = NEW.generative_image_model_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_touch_app_generative_image_model_updated_at
AFTER INSERT OR UPDATE ON app_generative_image_model_changes
FOR EACH ROW
EXECUTE FUNCTION touch_app_generative_image_model_updated_at();



-- =====================================================================
-- SOURCE: 20260117152211_seed_app_generative_image_models_table.sql
-- =====================================================================


-- Menggunakan Insert dengan ON CONFLICT agar aman dijalankan berulang (Idempotent)
INSERT INTO app_generative_image_models (
    model, 
    label, 
    provider, 
    is_active, 
    valid_ratios, 
    image_sizes
) VALUES 
(
    'gpt-image-1',
    'GPT Image 1',
    'openai',
    true,
    ARRAY['1:1', '2:3', '3:2'],
    NULL
),
(
    'gemini-2.5-flash-image',
    'Gemini 2.5 Flash Image',
    'google',
    true,
    ARRAY['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9', '21:9'],
    NULL
),
(
    'gemini-3-pro-image-preview',
    'Gemini 3 Pro Image Preview',
    'google',
    true,
    ARRAY['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9', '21:9'],
    ARRAY['1K', '2K', '4K']
)
ON CONFLICT (model) WHERE deleted_at IS NULL 
DO UPDATE SET
    label = EXCLUDED.label,
    provider = EXCLUDED.provider,
    valid_ratios = EXCLUDED.valid_ratios,
    image_sizes = EXCLUDED.image_sizes,
    updated_at = NOW();




-- =====================================================================
-- SOURCE: 20260117160514_create_app_generative_text_models_table.sql
-- =====================================================================


-- Provider khusus text (hanya openai dan google)
CREATE TYPE app_generative_text_model_provider_type AS ENUM ('openai', 'google');

CREATE TABLE IF NOT EXISTS app_generative_text_models (
    id BIGSERIAL PRIMARY KEY,
    -- ex: "gpt-4-turbo"
    model VARCHAR(255) NOT NULL,

    -- information
    -- ex: "GPT-4 Turbo"
    label VARCHAR(255) NOT NULL,
    -- path to icon/image (optional, consistent with image models)
    image VARCHAR(255),

    -- functional
    provider app_generative_text_model_provider_type NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT true,

    -- timestamp
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);

-- Partial Index untuk Unique Model (Soft Delete friendly)
CREATE UNIQUE INDEX app_generative_text_models_model_key 
ON app_generative_text_models (model) 
WHERE deleted_at IS NULL;

-- Trigger updated_at main table
CREATE TRIGGER trigger_app_generative_text_models_updated_at
BEFORE UPDATE ON app_generative_text_models
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- -- -- LOGGING / AUDIT TRAIL -- -- --

CREATE TABLE IF NOT EXISTS app_generative_text_model_changes (
    id BIGSERIAL PRIMARY KEY,
    action action_change_type NOT NULL, -- Enum shared

    -- actioner
    profile_id UUID NOT NULL,
    FOREIGN KEY (profile_id) REFERENCES profiles (id),

    -- relation
    generative_text_model_id BIGINT NOT NULL,
    FOREIGN KEY (generative_text_model_id) REFERENCES app_generative_text_models (id),

    -- SNAPSHOT BEFORE (Create: Before = After)
    before_model VARCHAR(255) NOT NULL,
    before_label VARCHAR(255) NOT NULL,
    before_image VARCHAR(255),
    before_provider app_generative_text_model_provider_type NOT NULL,
    before_is_active BOOLEAN NOT NULL,

    -- SNAPSHOT AFTER
    after_model VARCHAR(255) NOT NULL,
    after_label VARCHAR(255) NOT NULL,
    after_image VARCHAR(255),
    after_provider app_generative_text_model_provider_type NOT NULL,
    after_is_active BOOLEAN NOT NULL,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);

-- Trigger updated_at log table
CREATE TRIGGER trigger_app_generative_text_model_changes_updated_at
BEFORE UPDATE ON app_generative_text_model_changes
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- Trigger Update Parent Timestamp
CREATE OR REPLACE FUNCTION touch_app_generative_text_model_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE app_generative_text_models
  SET updated_at = now()
  WHERE id = NEW.generative_text_model_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_touch_app_generative_text_model_updated_at
AFTER INSERT OR UPDATE ON app_generative_text_model_changes
FOR EACH ROW
EXECUTE FUNCTION touch_app_generative_text_model_updated_at();




-- =====================================================================
-- SOURCE: 20260117160526_seed_app_generative_text_models_table.sql
-- =====================================================================


INSERT INTO app_generative_text_models (
    model, 
    label, 
    provider, 
    is_active
) VALUES 

-- ==========================================================================================
-- OPENAI MODELS
-- Input Image: Mendukung URL (Public) dan Base64.
-- ==========================================================================================

-- 1. GPT-4o (Omni)
-- Tipe: Flagship / High Intelligence.
-- Biaya: Menengah (Lebih hemat dari GPT-4 Turbo, tapi lebih mahal dari Mini).
-- Use Case: Analisis gambar yang kompleks, tulisan tangan sulit, atau butuh nuansa detail.
-- Input: URL & Base64.
(
    'gpt-4o',
    'GPT-4o (Omni)',
    'openai',
    true
),

-- 2. GPT-4o Mini
-- Tipe: Cost Efficient / Hemat.
-- Biaya: SANGAT MURAH (Sekitar 1/30 harga GPT-4o).
-- Use Case: Captioning massal, deskripsi produk standar, validasi gambar sederhana.
-- Input: URL & Base64.
(
    'gpt-4o-mini',
    'GPT-4o Mini',
    'openai',
    true
),

-- 3. GPT-4 Turbo (Legacy Vision)
-- Tipe: High End Legacy.
-- Biaya: MAHAL (Boros).
-- Note: Sebaiknya gunakan GPT-4o, tapi ini dimasukkan untuk backward compatibility.
-- Input: URL & Base64.
(
    'gpt-4-turbo',
    'GPT-4 Turbo',
    'openai',
    true
),

-- ==========================================================================================
-- GOOGLE GEMINI MODELS
-- Input Image: Utamanya Base64 (Inline Data) atau File API (Upload). 
-- Google API standar tidak langsung mendownload dari URL publik di payload request.
-- ==========================================================================================

-- 4. Gemini 1.5 Pro
-- Tipe: High Reasoning / Long Context.
-- Biaya: Menengah ke Atas (Tergantung panjang prompt/context).
-- Use Case: Analisis dokumen visual, chart, infografis, atau video panjang.
-- Input: Base64 (limitasi size) atau File API URI.
(
    'gemini-1.5-pro',
    'Gemini 1.5 Pro',
    'google',
    true
),

-- 5. Gemini 1.5 Flash
-- Tipe: High Speed / Cost Efficient.
-- Biaya: MURAH (Hemat).
-- Use Case: Alternatif murah untuk GPT-4o-mini, captioning cepat, OCR dokumen sederhana.
-- Input: Base64 (limitasi size) atau File API URI.
(
    'gemini-1.5-flash',
    'Gemini 1.5 Flash',
    'google',
    true
),

-- 6. Gemini 1.0 Pro Vision (Legacy)
-- Tipe: Legacy.
-- Biaya: Hemat.
-- Note: Model lama, kemampuan vision-nya di bawah 1.5 Flash. Hanya untuk legacy support.
-- Input: Base64.
(
    'gemini-pro-vision',
    'Gemini Pro Vision (Legacy)',
    'google',
    false -- Diset false (non-aktif) by default karena sudah ada 1.5 Flash
)

ON CONFLICT (model) WHERE deleted_at IS NULL 
DO UPDATE SET
    label = EXCLUDED.label,
    provider = EXCLUDED.provider,
    is_active = EXCLUDED.is_active,
    updated_at = NOW();




-- =====================================================================
-- SOURCE: 20260117215018_create_referral_records_table.sql
-- =====================================================================

-- record referral usage
CREATE TYPE referral_record_status AS ENUM ('pending', 'success', 'failed', 'canceled');

CREATE TABLE IF NOT EXISTS referral_records (
    id BIGSERIAL PRIMARY KEY,

    -- user that consume the referral code
    consumer_profile_id UUID NOT NULL,
    FOREIGN KEY (consumer_profile_id) REFERENCES profiles (id),

    -- business root that consume the referral code
    business_root_id BIGINT NOT NULL,
    FOREIGN KEY (business_root_id) REFERENCES business_roots (id),

    -- relation into referral code that used
    profile_referral_code_id BIGINT NOT NULL,
    FOREIGN KEY (profile_referral_code_id) REFERENCES profile_referral_codes (id),

    -- DENORMALIZED FOR RECORD
    -- ex: basic or special
    record_type referral_type NOT NULL,
    -- ex: Rp 10.000 or 10%
    record_total_discount BIGINT NOT NULL DEFAULT 0,
    record_discount_type discount_type NOT NULL DEFAULT 'fixed',
    -- if null there is no expiration
    record_expired_days INT,
    -- max discount for consumer
    record_max_discount BIGINT NOT NULL DEFAULT 0,
    -- max usage for consumer, if null there is no limit
    record_max_usage INT,
    -- ex: Rp 10.000
    record_reward_per_referral BIGINT NOT NULL DEFAULT 0,

    -- CONSUMER (hal yang didapat oleh consumer referral)
    -- discount amount granted to consumer (harus dalam satuan uang)
    discount_amount_granted BIGINT NOT NULL DEFAULT 0,
    -- currency untuk discount amount (saat ini hanya IDR)
    discount_currency VARCHAR(3) NOT NULL DEFAULT 'IDR',

    -- PRODUCER (hal yang didapat oleh producer referral)
    -- reward amount granted to producer (harus dalam satuan uang)
    reward_amount_granted BIGINT NOT NULL DEFAULT 0,
    -- currency untuk reward amount (saat ini hanya IDR)
    reward_currency VARCHAR(3) NOT NULL DEFAULT 'IDR',

    -- status for tracking usage (pending -> success/failed/canceled)
    status referral_record_status NOT NULL DEFAULT 'pending',
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);
CREATE TRIGGER trigger_referral_records_updated_at
BEFORE UPDATE ON referral_records
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();




-- =====================================================================
-- SOURCE: 20260117215846_create_payment_histories_table.sql
-- =====================================================================


-- payment_type nantinya ditambah jika ada product lainnya
CREATE TYPE payment_product_type AS ENUM ('image_token', 'video_token', 'livestream_token');

CREATE TYPE payment_status AS ENUM ('pending', 'success', 'failed', 'canceled', 'refunded', 'expired', 'denied');

CREATE TABLE IF NOT EXISTS payment_histories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- profile that make the payment
    profile_id UUID NOT NULL,
    FOREIGN KEY (profile_id) REFERENCES profiles (id),

    -- business root that make the payment
    business_root_id BIGINT NOT NULL,
    FOREIGN KEY (business_root_id) REFERENCES business_roots (id),

    -- common
    product_amount BIGINT NOT NULL,
    status payment_status NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'IDR',
    -- ex: OVO, Gopay, etc
    payment_method VARCHAR(255) NOT NULL,
    -- ex: bank, ewallet, etc
    payment_method_type VARCHAR(255) NOT NULL,

    -- informative (denormalized)
    -- product (app token product)
    record_product_name VARCHAR(255) NOT NULL,
    record_product_type payment_product_type NOT NULL,
    record_product_price BIGINT NOT NULL,
    record_product_image_url VARCHAR(255) NOT NULL,
    -- tidak perlu foreign key karena tidak perlu diakses (hanya untuk audit log)
    -- ex ambil dari app_token_products 
    reference_product_id UUID NOT NULL,

    -- payment details
    -- item
    -- ex: Rp 10.000
    subtotal_item_amount BIGINT NOT NULL,

    -- discount
    -- ex: Rp 10.000
    discount_amount BIGINT NOT NULL,
    -- jika discount fixed maka discount_percentage akan null
    discount_percentage INT,
    discount_type discount_type NOT NULL,

    -- admin fee
    admin_fee_amount BIGINT NOT NULL,
    admin_fee_percentage INT,
    -- pakai discount type karena sama dengan discount typenya
    admin_fee_type discount_type NOT NULL,

    -- tax
    -- ex: Rp 10.000 (tax pasti dari percentage)
    tax_amount BIGINT NOT NULL,
    tax_percentage INT NOT NULL,

    -- relation into referral_records for tracking referral (1 to 1 not mandatory)
    referral_record_id BIGINT,
    FOREIGN KEY (referral_record_id) REFERENCES referral_records (id),

    -- midtrans
    midtrans_transaction_id VARCHAR(255),
    midtrans_expired_at TIMESTAMPTZ,

    -- payment lifecycle timestamps
    payment_pending_at TIMESTAMPTZ,      -- saat pertama kali checkout
    payment_success_at TIMESTAMPTZ,      -- saat pembayaran berhasil
    payment_failed_at TIMESTAMPTZ,       -- saat pembayaran gagal
    payment_canceled_at TIMESTAMPTZ,     -- saat user cancel
    payment_expired_at TIMESTAMPTZ,      -- saat expired
    payment_refunded_at TIMESTAMPTZ,     -- saat refund

    -- grand total (setelah semua kalkulasi)
    total_amount BIGINT NOT NULL,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ
);
CREATE TRIGGER trigger_payment_histories_updated_at
BEFORE UPDATE ON payment_histories
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();




-- =====================================================================
-- SOURCE: 20260118085914_create_payment_history_actions_table.sql
-- =====================================================================


-- Enum for action value type
CREATE TYPE payment_action_value_type AS ENUM ('image', 'link', 'text', 'claim');

-- Table: payment_history_actions
-- Stores actions (Gopay) or VA numbers (Bank Transfer) from Midtrans
CREATE TABLE IF NOT EXISTS payment_history_actions (
    id BIGSERIAL PRIMARY KEY,
    
    -- relation to payment_histories
    payment_history_id UUID NOT NULL,
    FOREIGN KEY (payment_history_id) REFERENCES payment_histories (id) ON DELETE CASCADE,
    
    -- action details
    name VARCHAR(100) NOT NULL,                              -- dari midtrans (generate-qr-code, deeplink-redirect, dll)
    label VARCHAR(255) NOT NULL,                             -- label readable (QR Code, Deeplink Redirect, Virtual Account)
    value TEXT NOT NULL,                                     -- url atau va number
    value_type payment_action_value_type NOT NULL,           -- image, link, text, claim
    payment_type app_payment_method_type NOT NULL,           -- bank atau ewallet (reuse existing enum)
    action_method VARCHAR(10) NOT NULL DEFAULT 'GET',        -- GET, POST (VA default GET)
    is_public BOOLEAN NOT NULL DEFAULT TRUE,                 -- filter mana yang ditampilkan ke user
    
    -- timestamp
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index untuk query by payment_history_id
CREATE INDEX idx_payment_history_actions_payment_id 
ON payment_history_actions (payment_history_id);

-- Trigger for updated_at
CREATE TRIGGER trigger_payment_history_actions_updated_at
BEFORE UPDATE ON payment_history_actions
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();




